<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cnmn Quiz Generator</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(165deg, #fdfbf7 0%, #f5e6d3 50%, #ecdbc8 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    h1 {
      color: #6b3410;
      margin-bottom: 10px;
      font-size: 28px;
      letter-spacing: 2px;
    }

    .subtitle {
      color: #8b6340;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 4px 20px rgba(107, 52, 16, 0.1);
      margin-bottom: 20px;
    }

    .panel h2 {
      color: #6b3410;
      margin-bottom: 16px;
      font-size: 18px;
    }

    .form-row {
      display: flex;
      gap: 12px;
      align-items: end;
      margin-bottom: 16px;
    }

    .form-group {
      flex: 1;
    }

    label {
      display: block;
      margin-bottom: 6px;
      color: #6b3410;
      font-weight: 600;
      font-size: 13px;
    }

    input[type="text"], select {
      width: 100%;
      padding: 10px 12px;
      border: 2px solid #c4a574;
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #6b3410;
    }

    button {
      background: #6b3410;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    button:hover {
      background: #8b4513;
    }

    button:disabled {
      background: #c4a574;
      cursor: not-allowed;
    }

    button.small {
      padding: 6px 10px;
      font-size: 12px;
    }

    button.secondary {
      background: #8b6340;
    }

    button.export {
      background: #2e7d32;
    }

    button.export:hover {
      background: #388e3c;
    }

    .hint {
      font-size: 12px;
      color: #8b6340;
      margin-top: 4px;
      font-style: italic;
    }


    /* Provider selection */
    .provider-bar {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 2px solid #ecdbc8;
    }

    .provider-btn {
      padding: 8px 16px;
      border: 2px solid #c4a574;
      background: white;
      color: #6b3410;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }

    .provider-btn:hover {
      border-color: #6b3410;
    }

    .provider-btn.selected {
      background: #6b3410;
      color: white;
      border-color: #6b3410;
    }

    .provider-btn.unavailable {
      opacity: 0.4;
      pointer-events: none;
    }

    .provider-status {
      font-size: 12px;
      color: #8b6340;
      margin-left: auto;
      align-self: center;
    }

    /* Question cards */
    .questions-grid {
      display: grid;
      gap: 16px;
    }

    .question-card {
      background: white;
      border: 2px solid #ecdbc8;
      border-radius: 12px;
      padding: 16px;
    }

    .question-card h3 {
      color: #6b3410;
      font-size: 14px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .question-card h3 .num {
      background: #6b3410;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .field-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    .field-row label {
      width: 70px;
      margin: 0;
      font-size: 12px;
    }

    .field-row input {
      flex: 1;
      padding: 6px 10px;
      font-size: 13px;
    }

    .disguise-preview {
      font-family: 'Courier New', monospace;
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      min-width: 60px;
      text-align: center;
    }

    .disguise-input {
      font-family: 'Courier New', monospace;
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      width: 70px;
      text-align: center;
      border: 2px solid #2d2d2d;
    }

    .disguise-input:focus {
      border-color: #6b3410;
      outline: none;
    }

    .type-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      background: #ecdbc8;
      color: #6b3410;
      white-space: nowrap;
    }

    .type-badge.wrong-letters { background: #ffcdd2; color: #c62828; }
    .type-badge.non-synonym { background: #fff3e0; color: #e65100; }
    .type-badge.phonetic-trap { background: #e3f2fd; color: #1565c0; }

    .type-badge.clickable {
      cursor: pointer;
    }
    .type-badge.clickable:hover {
      opacity: 0.8;
    }

    .distractors-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #ecdbc8;
    }

    .distractors-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .distractors-header label {
      font-size: 12px;
      margin: 0;
    }

    /* Loading state */
    .loading {
      text-align: center;
      padding: 40px;
      color: #8b6340;
    }

    .spinner {
      border: 3px solid #ecdbc8;
      border-top: 3px solid #6b3410;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }

    /* Export section */
    .export-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid #ecdbc8;
      display: flex;
      gap: 12px;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #8b6340;
    }

    .empty-state h3 {
      color: #6b3410;
      margin-bottom: 8px;
    }

    /* Emoji picker */
    .emoji-picker-container {
      position: relative;
      display: inline-block;
    }

    .emoji-btn {
      width: 40px;
      height: 36px;
      font-size: 20px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 2px solid #c4a574;
      color: #6b3410;
    }

    .emoji-btn:hover {
      background: #f5e6d3;
    }

    .emoji-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      z-index: 100;
      background: white;
      border: 2px solid #c4a574;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      width: 340px;
      flex-direction: column;
    }

    .emoji-dropdown.open {
      display: flex;
    }

    .emoji-search {
      padding: 10px;
      border-bottom: 1px solid #ecdbc8;
    }

    .emoji-search input {
      width: 100%;
      padding: 8px 12px;
      border: 2px solid #ecdbc8;
      border-radius: 6px;
      font-size: 13px;
      outline: none;
    }

    .emoji-search input:focus {
      border-color: #c4a574;
    }

    .emoji-tabs {
      display: flex;
      border-bottom: 1px solid #ecdbc8;
      padding: 0 6px;
      overflow-x: auto;
      scrollbar-width: none;
    }

    .emoji-tabs::-webkit-scrollbar {
      display: none;
    }

    .emoji-tab {
      padding: 8px 6px;
      font-size: 18px;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      opacity: 0.5;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .emoji-tab:hover {
      opacity: 0.8;
    }

    .emoji-tab.active {
      opacity: 1;
      border-bottom-color: #6b3410;
    }

    .emoji-grid-container {
      height: 200px;
      overflow-y: auto;
      padding: 8px;
    }

    .emoji-section-label {
      font-size: 11px;
      color: #8b6340;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 4px 4px 8px;
      font-weight: 600;
    }

    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
    }

    .emoji-option {
      width: 34px;
      height: 34px;
      font-size: 22px;
      background: none;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.15s;
    }

    .emoji-option:hover {
      background: #f5e6d3;
      transform: scale(1.15);
    }

    .emoji-footer {
      display: flex;
      justify-content: space-between;
      padding: 8px 10px;
      border-top: 1px solid #ecdbc8;
      background: #faf7f2;
      border-radius: 0 0 10px 10px;
    }

    .emoji-clear {
      background: #ecdbc8;
      color: #6b3410;
      font-size: 11px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }

    .emoji-clear:hover {
      background: #dcc9a8;
    }

    .emoji-no-results {
      text-align: center;
      padding: 30px;
      color: #8b6340;
      font-size: 13px;
    }

    .emoji-direct-input {
      width: 90px;
      padding: 5px 8px;
      border: 2px solid #ecdbc8;
      border-radius: 4px;
      font-size: 16px;
      text-align: center;
    }

    .emoji-direct-input:focus {
      border-color: #c4a574;
      outline: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>cnmn Quiz Generator</h1>
    <p class="subtitle">Generate themed synonym puzzles with phonetic disguises</p>

    <!-- Provider Selection -->
    <div class="panel">
      <div class="provider-bar">
        <button class="provider-btn selected" data-provider="openai" onclick="selectProvider('openai')">OpenAI</button>
        <button class="provider-btn" data-provider="anthropic" onclick="selectProvider('anthropic')">Anthropic</button>
        <button class="provider-btn" data-provider="rules" onclick="selectProvider('rules')">Rule-Based</button>
        <span class="provider-status" id="providerStatus">Checking...</span>
      </div>

      <div class="form-row">
        <div class="form-group">
          <label>Theme</label>
          <input type="text" id="themeInput" placeholder="e.g., Buildings, Emotions, Weather, Animals">
        </div>
        <div class="form-group" style="max-width: 180px;">
          <label>Publication Date</label>
          <input type="date" id="pubDate">
        </div>
        <button onclick="generateQuiz()" id="generateBtn">Generate 6 Questions</button>
      </div>
      <p class="hint">Enter a theme and publication date to generate 6 synonym quiz questions.</p>
    </div>

    <!-- Questions -->
    <div class="panel" id="questionsPanel">
      <h2>Quiz Questions</h2>

      <div id="questionsContainer">
        <div class="empty-state">
          <h3>No quiz generated yet</h3>
          <p>Enter a theme above and click "Generate 6 Questions"</p>
        </div>
      </div>

      <div class="export-section hidden" id="exportSection">
        <button class="export" onclick="saveQuiz()">üíæ Save Puzzle</button>
        <button class="secondary" onclick="exportQuiz()">üìã Copy JSON</button>
        <button class="secondary" onclick="clearQuiz()">üóëÔ∏è Clear</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let currentProvider = 'openai';
    let availableProviders = { openai: false, anthropic: false };
    let quiz = {
      theme: '',
      publicationDate: '',
      questions: []  // Array of 6 question objects
    };

    // Initialize date picker to tomorrow
    document.addEventListener('DOMContentLoaded', () => {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      document.getElementById('pubDate').value = tomorrow.toISOString().split('T')[0];
    });

    // Question structure:
    // {
    //   prompt: "shed",
    //   emoji: "üè†",
    //   rejectedPrompts: [],
    //   answer: { word: "GARAGE", disguise: "grj" },
    //   rejectedAnswers: [],
    //   distractors: [
    //     { word: "LEAN-TO", disguise: "lntso", type: "wrong-letters" },
    //     { word: "PORCH", disguise: "prch", type: "non-synonym" },
    //     { word: "SHACK", disguise: "chk", type: "phonetic-trap" }
    //   ],
    //   rejectedDistractors: []
    // }

    // Comprehensive emoji data organized by category
    const emojiCategories = {
      'Smileys': {
        icon: 'üòÄ',
        emojis: ['üòÄ','üòÉ','üòÑ','üòÅ','üòÖ','üòÇ','ü§£','üòä','üòá','üôÇ','üòâ','üòå','üòç','ü•∞','üòò','üòã','üòõ','üòú','ü§™','üòù','ü§ë','ü§ó','ü§≠','ü§´','ü§î','ü§ê','ü§®','üòê','üòë','üò∂','üòè','üòí','üôÑ','üò¨','üòÆ‚Äçüí®','ü§•','üòå','üòî','üò™','ü§§','üò¥','üò∑','ü§í','ü§ï','ü§¢','ü§Æ','ü§ß','ü•µ','ü•∂','ü•¥','üòµ','ü§Ø','ü§†','ü•≥','ü•∏','üòé','ü§ì','üßê','üòï','üòü','üôÅ','‚òπÔ∏è','üòÆ','üòØ','üò≤','üò≥','ü•∫','üò¶','üòß','üò®','üò∞','üò•','üò¢','üò≠','üò±','üòñ','üò£','üòû','üòì','üò©','üò´','ü•±','üò§','üò°','üò†','ü§¨','üòà','üëø','üíÄ','‚ò†Ô∏è','üí©','ü§°','üëπ','üë∫','üëª','üëΩ','üëæ','ü§ñ']
      },
      'People': {
        icon: 'üëã',
        emojis: ['üëã','ü§ö','üñêÔ∏è','‚úã','üññ','üëå','ü§å','ü§è','‚úåÔ∏è','ü§û','ü§ü','ü§ò','ü§ô','üëà','üëâ','üëÜ','üñï','üëá','‚òùÔ∏è','üëç','üëé','‚úä','üëä','ü§õ','ü§ú','üëè','üôå','üëê','ü§≤','ü§ù','üôè','‚úçÔ∏è','üíÖ','ü§≥','üí™','ü¶æ','ü¶ø','ü¶µ','ü¶∂','üëÇ','ü¶ª','üëÉ','üß†','ü´Ä','ü´Å','ü¶∑','ü¶¥','üëÄ','üëÅÔ∏è','üëÖ','üëÑ','üë∂','üßí','üë¶','üëß','üßë','üë±','üë®','üßî','üë©','üßì','üë¥','üëµ','üôç','üôé','üôÖ','üôÜ','üíÅ','üôã','üßè','üôá','ü§¶','ü§∑','üëÆ','üïµÔ∏è','üíÇ','ü•∑','üë∑','ü§¥','üë∏','üë≥','üë≤','üßï','ü§µ','üë∞','ü§∞','ü´É','ü´Ñ','ü§±','üëº','üéÖ','ü§∂','ü¶∏','ü¶π','üßô','üßö','üßõ','üßú','üßù','üßû','üßü','üíÜ','üíá','üö∂','üßç','üßé','üèÉ','üíÉ','üï∫','üï¥Ô∏è','üëØ','üßñ','üßó','ü§∏','üèåÔ∏è','üèá','‚õ∑Ô∏è','üèÇ','üèãÔ∏è','ü§º','ü§Ω','ü§æ','ü§∫','‚õπÔ∏è','üèä','üö£','üßò','üõÄ','üõå']
      },
      'Animals': {
        icon: 'üêæ',
        emojis: ['üê∂','üêï','ü¶Æ','üêï‚Äçü¶∫','üê©','üê∫','ü¶ä','ü¶ù','üê±','üêà','üêà‚Äç‚¨õ','ü¶Å','üêØ','üêÖ','üêÜ','üê¥','üêé','ü¶Ñ','ü¶ì','ü¶å','ü¶¨','üêÆ','üêÇ','üêÉ','üêÑ','üê∑','üêñ','üêó','üêΩ','üêè','üêë','üêê','üê™','üê´','ü¶ô','ü¶í','üêò','ü¶£','ü¶è','ü¶õ','üê≠','üêÅ','üêÄ','üêπ','üê∞','üêá','üêøÔ∏è','ü¶´','ü¶î','ü¶á','üêª','üêª‚Äç‚ùÑÔ∏è','üê®','üêº','ü¶•','ü¶¶','ü¶®','ü¶ò','ü¶°','üêæ','ü¶É','üêî','üêì','üê£','üê§','üê•','üê¶','üêß','üïäÔ∏è','ü¶Ö','ü¶Ü','ü¶¢','ü¶â','ü¶§','ü™∂','ü¶©','ü¶ö','ü¶ú','üê∏','üêä','üê¢','ü¶é','üêç','üê≤','üêâ','ü¶ï','ü¶ñ','üê≥','üêã','üê¨','ü¶≠','üêü','üê†','üê°','ü¶à','üêô','üêö','üêå','ü¶ã','üêõ','üêú','üêù','ü™≤','üêû','ü¶ó','ü™≥','üï∑Ô∏è','üï∏Ô∏è','ü¶Ç','ü¶ü','ü™∞','ü™±','ü¶†']
      },
      'Nature': {
        icon: 'üåø',
        emojis: ['üíê','üå∏','üíÆ','üèµÔ∏è','üåπ','ü•Ä','üå∫','üåª','üåº','üå∑','üå±','ü™¥','üå≤','üå≥','üå¥','üåµ','üåæ','üåø','‚òòÔ∏è','üçÄ','üçÅ','üçÇ','üçÉ','üçá','üçà','üçâ','üçä','üçã','üçå','üçç','ü•≠','üçé','üçè','üçê','üçë','üçí','üçì','ü´ê','ü•ù','üçÖ','ü´í','ü••','ü•ë','üçÜ','ü•î','ü•ï','üåΩ','üå∂Ô∏è','ü´ë','ü•í','ü•¨','ü•¶','üßÑ','üßÖ','üçÑ','ü•ú','üå∞','üçû','ü•ê','ü•ñ','ü´ì','ü•®','ü•Ø','ü•û','üßá','üßÄ','üçñ','üçó','ü•©','ü•ì','üçî','üçü','üçï','üå≠','ü•™','üåÆ','üåØ','ü´î','ü•ô','üßÜ','ü•ö','üç≥','ü•ò','üç≤','ü´ï','ü•£','ü•ó','üçø','üßà','üßÇ','ü•´','üç±','üçò','üçô','üçö','üçõ','üçú','üçù','üç†','üç¢','üç£','üç§','üç•','ü•Æ','üç°','ü•ü','ü•†','ü•°','ü¶Ä','ü¶û','ü¶ê','ü¶ë','ü¶™','üç¶','üçß','üç®','üç©','üç™','üéÇ','üç∞','üßÅ','ü•ß','üç´','üç¨','üç≠','üçÆ','üçØ','üçº','ü•õ','‚òï','ü´ñ','üçµ','üç∂','üçæ','üç∑','üç∏','üçπ','üç∫','üçª','ü•Ç','ü•É','ü•§','üßã','üßÉ','üßâ','üßä']
      },
      'Travel': {
        icon: '‚úàÔ∏è',
        emojis: ['üöó','üöï','üöô','üöå','üöé','üèéÔ∏è','üöì','üöë','üöí','üöê','üõª','üöö','üöõ','üöú','üèçÔ∏è','üõµ','üö≤','üõ¥','üõπ','üõº','üöè','üõ£Ô∏è','üõ§Ô∏è','üõ¢Ô∏è','‚õΩ','üö®','üö•','üö¶','üõë','üöß','‚öì','‚õµ','üõ∂','üö§','üõ≥Ô∏è','‚õ¥Ô∏è','üõ•Ô∏è','üö¢','‚úàÔ∏è','üõ©Ô∏è','üõ´','üõ¨','ü™Ç','üí∫','üöÅ','üöü','üö†','üö°','üõ∞Ô∏è','üöÄ','üõ∏','üõéÔ∏è','üß≥','‚åõ','‚è≥','‚åö','‚è∞','‚è±Ô∏è','‚è≤Ô∏è','üï∞Ô∏è','üå°Ô∏è','üó∫Ô∏è','üß≠','üèîÔ∏è','‚õ∞Ô∏è','üåã','üóª','üèïÔ∏è','üèñÔ∏è','üèúÔ∏è','üèùÔ∏è','üèûÔ∏è','üèüÔ∏è','üèõÔ∏è','üèóÔ∏è','üß±','ü™®','ü™µ','üõñ','üèòÔ∏è','üèöÔ∏è','üè†','üè°','üè¢','üè£','üè§','üè•','üè¶','üè®','üè©','üè™','üè´','üè¨','üè≠','üèØ','üè∞','üíí','üóº','üóΩ','‚õ™','üïå','üõï','üïç','‚õ©Ô∏è','üïã','‚õ≤','‚õ∫','üåÅ','üåÉ','üèôÔ∏è','üåÑ','üåÖ','üåÜ','üåá','üåâ','üé†','üé°','üé¢','üíà','üé™']
      },
      'Activities': {
        icon: '‚öΩ',
        emojis: ['‚öΩ','üèÄ','üèà','‚öæ','ü•é','üéæ','üèê','üèâ','ü•è','üé±','ü™Ä','üèì','üè∏','üèí','üèë','ü•ç','üèè','ü™É','ü•Ö','‚õ≥','ü™Å','üèπ','üé£','ü§ø','ü•ä','ü•ã','üéΩ','üõ∑','üéø','‚õ∑Ô∏è','üèÇ','ü™Ç','üèãÔ∏è','ü§º','ü§∏','ü§∫','‚õπÔ∏è','ü§æ','üèåÔ∏è','üèá','‚õ∏Ô∏è','üèä','üö¥','üöµ','üßó','ü§Ω','üéñÔ∏è','üèÜ','ü•á','ü•à','ü•â','üéÉ','üéÑ','üéÜ','üéá','üß®','‚ú®','üéà','üéâ','üéä','üéã','üéç','üéé','üéè','üéê','üéë','üßß','üéÄ','üéÅ','üéóÔ∏è','üéüÔ∏è','üé´','üé†','üé°','üé¢','üé™','üé≠','üñºÔ∏è','üé®','üßµ','ü™°','üß∂','ü™¢']
      },
      'Objects': {
        icon: 'üí°',
        emojis: ['‚åö','üì±','üì≤','üíª','‚å®Ô∏è','üñ•Ô∏è','üñ®Ô∏è','üñ±Ô∏è','üñ≤Ô∏è','üïπÔ∏è','üóúÔ∏è','üíΩ','üíæ','üíø','üìÄ','üìº','üì∑','üì∏','üìπ','üé•','üìΩÔ∏è','üéûÔ∏è','üìû','‚òéÔ∏è','üìü','üì†','üì∫','üìª','üéôÔ∏è','üéöÔ∏è','üéõÔ∏è','üß≠','‚è±Ô∏è','‚è≤Ô∏è','‚è∞','üï∞Ô∏è','‚åõ','‚è≥','üì°','üîã','üîå','üí°','üî¶','üïØÔ∏è','ü™î','üßØ','üõ¢Ô∏è','üí∏','üíµ','üí¥','üí∂','üí∑','ü™ô','üí∞','üí≥','üíé','‚öñÔ∏è','ü™ú','üß∞','ü™õ','üîß','üî®','‚öíÔ∏è','üõ†Ô∏è','‚õèÔ∏è','ü™ö','üî©','‚öôÔ∏è','ü™§','üß±','‚õìÔ∏è','üß≤','üî´','üí£','üß®','ü™ì','üî™','üó°Ô∏è','‚öîÔ∏è','üõ°Ô∏è','üö¨','‚ö∞Ô∏è','ü™¶','‚ö±Ô∏è','üè∫','üîÆ','üìø','üßø','üíà','‚öóÔ∏è','üî≠','üî¨','üï≥Ô∏è','ü©π','ü©∫','üíä','üíâ','ü©∏','üß¨','ü¶†','üß´','üß™','üå°Ô∏è','üßπ','ü™†','üß∫','üßª','üöΩ','üö∞','üöø','üõÅ','üõÄ','üßº','ü™•','ü™í','üßΩ','ü™£','üß¥','üõéÔ∏è','üîë','üóùÔ∏è','üö™','ü™ë','üõãÔ∏è','üõèÔ∏è','üõå','üß∏','ü™Ü','üñºÔ∏è','ü™û','ü™ü','üõí','üéÅ','üéà','üéè','üéÄ','ü™Ñ','ü™Ö','üéä','üéâ','üéé','üèÆ','üéê','üßß','‚úâÔ∏è','üì©','üì®','üìß','üíå','üì•','üì§','üì¶','üè∑Ô∏è','üì™','üì´','üì¨','üì≠','üìÆ','üìØ','üìú','üìÉ','üìÑ','üìë','üßæ','üìä','üìà','üìâ','üóíÔ∏è','üóìÔ∏è','üìÜ','üìÖ','üóëÔ∏è','üìá','üóÉÔ∏è','üó≥Ô∏è','üóÑÔ∏è','üìã','üìÅ','üìÇ','üóÇÔ∏è','üóûÔ∏è','üì∞','üìì','üìî','üìí','üìï','üìó','üìò','üìô','üìö','üìñ','üîñ','üß∑','üîó','üìé','üñáÔ∏è','üìê','üìè','üßÆ','üìå','üìç','‚úÇÔ∏è','üñäÔ∏è','üñãÔ∏è','‚úíÔ∏è','üñåÔ∏è','üñçÔ∏è','üìù','‚úèÔ∏è','üîç','üîé','üîè','üîê','üîí','üîì']
      },
      'Symbols': {
        icon: '‚ù§Ô∏è',
        emojis: ['‚ù§Ô∏è','üß°','üíõ','üíö','üíô','üíú','üñ§','ü§ç','ü§é','üíî','‚ù£Ô∏è','üíï','üíû','üíì','üíó','üíñ','üíò','üíù','üíü','‚òÆÔ∏è','‚úùÔ∏è','‚ò™Ô∏è','üïâÔ∏è','‚ò∏Ô∏è','‚ú°Ô∏è','üîØ','üïé','‚òØÔ∏è','‚ò¶Ô∏è','üõê','‚õé','‚ôà','‚ôâ','‚ôä','‚ôã','‚ôå','‚ôç','‚ôé','‚ôè','‚ôê','‚ôë','‚ôí','‚ôì','üÜî','‚öõÔ∏è','üâë','‚ò¢Ô∏è','‚ò£Ô∏è','üì¥','üì≥','üà∂','üàö','üà∏','üà∫','üà∑Ô∏è','‚ú¥Ô∏è','üÜö','üíÆ','üâê','„äôÔ∏è','„äóÔ∏è','üà¥','üàµ','üàπ','üà≤','üÖ∞Ô∏è','üÖ±Ô∏è','üÜé','üÜë','üÖæÔ∏è','üÜò','‚ùå','‚≠ï','üõë','‚õî','üìõ','üö´','üíØ','üí¢','‚ô®Ô∏è','üö∑','üöØ','üö≥','üö±','üîû','üìµ','üö≠','‚ùó','‚ùï','‚ùì','‚ùî','‚ÄºÔ∏è','‚ÅâÔ∏è','üîÖ','üîÜ','„ÄΩÔ∏è','‚ö†Ô∏è','üö∏','üî±','‚öúÔ∏è','üî∞','‚ôªÔ∏è','‚úÖ','üàØ','üíπ','‚ùáÔ∏è','‚ú≥Ô∏è','‚ùé','üåê','üí†','‚ìÇÔ∏è','üåÄ','üí§','üèß','üöæ','‚ôø','üÖøÔ∏è','üõó','üà≥','üàÇÔ∏è','üõÇ','üõÉ','üõÑ','üõÖ','üöπ','üö∫','üöº','‚ößÔ∏è','üöª','üöÆ','üé¶','üì∂','üàÅ','üî£','‚ÑπÔ∏è','üî§','üî°','üî†','üÜñ','üÜó','üÜô','üÜí','üÜï','üÜì','0Ô∏è‚É£','1Ô∏è‚É£','2Ô∏è‚É£','3Ô∏è‚É£','4Ô∏è‚É£','5Ô∏è‚É£','6Ô∏è‚É£','7Ô∏è‚É£','8Ô∏è‚É£','9Ô∏è‚É£','üîü','üî¢','#Ô∏è‚É£','*Ô∏è‚É£','‚èèÔ∏è','‚ñ∂Ô∏è','‚è∏Ô∏è','‚èØÔ∏è','‚èπÔ∏è','‚è∫Ô∏è','‚è≠Ô∏è','‚èÆÔ∏è','‚è©','‚è™','‚è´','‚è¨','‚óÄÔ∏è','üîº','üîΩ','‚û°Ô∏è','‚¨ÖÔ∏è','‚¨ÜÔ∏è','‚¨áÔ∏è','‚ÜóÔ∏è','‚ÜòÔ∏è','‚ÜôÔ∏è','‚ÜñÔ∏è','‚ÜïÔ∏è','‚ÜîÔ∏è','‚Ü™Ô∏è','‚Ü©Ô∏è','‚§¥Ô∏è','‚§µÔ∏è','üîÄ','üîÅ','üîÇ','üîÑ','üîÉ','‚ûø','üîö','üîô','üîõ','üîù','üîú','‚úîÔ∏è','‚òëÔ∏è','üîò','üî¥','üü†','üü°','üü¢','üîµ','üü£','‚ö´','‚ö™','üü§','üî∫','üîª','üî∏','üîπ','üî∂','üî∑','üî≥','üî≤','‚ñ™Ô∏è','‚ñ´Ô∏è','‚óæ','‚óΩ','‚óºÔ∏è','‚óªÔ∏è','üü•','üüß','üü®','üü©','üü¶','üü™','‚¨õ','‚¨ú','üü´','üîà','üîá','üîâ','üîä','üîî','üîï','üì£','üì¢','üëÅÔ∏è‚Äçüó®Ô∏è','üí¨','üí≠','üóØÔ∏è','‚ô†Ô∏è','‚ô£Ô∏è','‚ô•Ô∏è','‚ô¶Ô∏è','üÉè','üé¥','üÄÑ']
      },
      'Weather': {
        icon: '‚òÄÔ∏è',
        emojis: ['‚òÄÔ∏è','üå§Ô∏è','‚õÖ','üå•Ô∏è','‚òÅÔ∏è','üå¶Ô∏è','üåßÔ∏è','‚õàÔ∏è','üå©Ô∏è','üå®Ô∏è','‚ùÑÔ∏è','üå¨Ô∏è','üí®','üå™Ô∏è','üå´Ô∏è','üåà','‚òî','‚ö°','‚ùÑÔ∏è','üî•','üíß','üåä','‚≠ê','üåü','‚ú®','üí´','üåô','üåõ','üåú','üåù','üåû','ü™ê','‚ö°','‚òÑÔ∏è','üåç','üåé','üåè','üåë','üåí','üåì','üåî','üåï','üåñ','üåó','üåò']
      },
      'Flags': {
        icon: 'üè≥Ô∏è',
        emojis: ['üè≥Ô∏è','üè¥','üè¥‚Äç‚ò†Ô∏è','üèÅ','üö©','üéå','üè≥Ô∏è‚Äçüåà','üè≥Ô∏è‚Äç‚ößÔ∏è','üá∫üá∏','üá¨üáß','üá®üá¶','üá¶üá∫','üá´üá∑','üá©üá™','üáÆüáπ','üá™üá∏','üáØüáµ','üá∞üá∑','üá®üá≥','üáÆüá≥','üáßüá∑','üá≤üáΩ','üá∑üá∫','üáøüá¶','üá≥üá±','üáßüá™','üá®üá≠','üá¶üáπ','üá∏üá™','üá≥üá¥','üá©üá∞','üá´üáÆ','üáµüá±','üáÆüá™','üáµüáπ','üá¨üá∑','üáπüá∑','üá™üá¨','üáÆüá±','üá∏üá¶','üá¶üá™','üáπüá≠','üáªüá≥','üáÆüá©','üáµüá≠','üá≤üáæ','üá∏üá¨','üá≥üáø','üá¶üá∑','üá®üá±','üá®üá¥','üáµüá™','üáªüá™']
      }
    };

    // Track recently used emojis
    let recentEmojis = JSON.parse(localStorage.getItem('cnmn-recent-emojis') || '[]');
    let currentEmojiCategory = 'Smileys';
    let emojiSearchQuery = '';

    // Load providers
    async function loadProviders() {
      const status = document.getElementById('providerStatus');
      try {
        const response = await fetch('/api/providers');
        availableProviders = await response.json();

        document.querySelectorAll('.provider-btn').forEach(btn => {
          const provider = btn.dataset.provider;
          if (provider === 'rules') return;
          if (!availableProviders[provider]) {
            btn.classList.add('unavailable');
          }
        });

        const available = [];
        if (availableProviders.openai) available.push('OpenAI');
        if (availableProviders.anthropic) available.push('Anthropic');

        if (available.length > 0) {
          status.textContent = `Available: ${available.join(', ')}`;
          if (availableProviders.openai) selectProvider('openai');
          else if (availableProviders.anthropic) selectProvider('anthropic');
          else selectProvider('rules');
        } else {
          status.textContent = 'No AI configured - using rules';
          selectProvider('rules');
        }
      } catch (e) {
        status.textContent = 'Server offline - using rules';
        document.querySelector('[data-provider="openai"]').classList.add('unavailable');
        document.querySelector('[data-provider="anthropic"]').classList.add('unavailable');
        selectProvider('rules');
      }
    }

    function selectProvider(provider) {
      currentProvider = provider;
      document.querySelectorAll('.provider-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.provider === provider);
      });
    }

    // ============================================
    // DISGUISE GENERATION & VALIDATION
    // ============================================

    // Validation guardrails for disguises
    const DisguiseValidator = {
      // Check basic format requirements
      isValidFormat(disguise) {
        if (!disguise || typeof disguise !== 'string') return { valid: false, reason: 'Empty or invalid' };
        const d = disguise.toLowerCase().trim();
        if (d.length < 2) return { valid: false, reason: 'Too short (< 2 chars)' };
        if (d.length > 10) return { valid: false, reason: 'Too long (> 10 chars)' };
        if (!/^[a-z]+$/.test(d)) return { valid: false, reason: 'Contains non-letter characters' };
        return { valid: true };
      },

      // Check if disguise is too similar to original word
      isTooSimilarToWord(disguise, word) {
        const d = disguise.toLowerCase();
        const w = word.toLowerCase();
        if (d === w) return { valid: false, reason: 'Identical to original word' };
        if (w.includes(d) && d.length > 2) return { valid: false, reason: 'Word contains disguise as substring' };
        if (d.includes(w)) return { valid: false, reason: 'Disguise contains word as substring' };
        return { valid: true };
      },

      // Check answer disguise
      validateAnswerDisguise(disguise, word) {
        const formatCheck = this.isValidFormat(disguise);
        if (!formatCheck.valid) return formatCheck;

        const similarCheck = this.isTooSimilarToWord(disguise, word);
        if (!similarCheck.valid) return similarCheck;

        return { valid: true };
      },

      // Check distractor disguise
      validateDistractor(distractor, answerDisguise, answerWord, prompt, allDisguises = []) {
        const formatCheck = this.isValidFormat(distractor);
        if (!formatCheck.valid) return formatCheck;

        const d = distractor.toLowerCase();
        const ans = answerDisguise.toLowerCase();
        const ansWord = answerWord.toLowerCase();
        const p = prompt.toLowerCase();

        // Can't match the answer disguise
        if (d === ans) return { valid: false, reason: 'Identical to answer disguise' };

        // Can't be the answer word's consonants exactly
        const ansConsonants = ansWord.replace(/[aeiou]/g, '');
        if (d === ansConsonants) return { valid: false, reason: 'Matches answer consonant pattern' };

        // Can't be the prompt's consonants
        const promptConsonants = p.replace(/[aeiou]/g, '');
        if (d === promptConsonants) return { valid: false, reason: 'Matches prompt consonant pattern' };

        // Can't duplicate another distractor
        if (allDisguises.some(existing => existing.toLowerCase() === d)) {
          return { valid: false, reason: 'Duplicate of another option' };
        }

        // Length should be within ¬±3 of answer disguise
        if (Math.abs(d.length - ans.length) > 3) {
          return { valid: false, reason: `Length too different from answer (${d.length} vs ${ans.length})` };
        }

        return { valid: true };
      },

      // Validate all options together
      validateOptionSet(answerDisguise, distractors) {
        const all = [answerDisguise, ...distractors].map(d => d.toLowerCase());

        // Check for duplicates
        const unique = new Set(all);
        if (unique.size !== all.length) {
          return { valid: false, reason: 'Duplicate disguises in option set' };
        }

        // Check no option is substring of another
        for (let i = 0; i < all.length; i++) {
          for (let j = 0; j < all.length; j++) {
            if (i !== j && all[j].includes(all[i]) && all[i].length > 2) {
              return { valid: false, reason: `"${all[i]}" is substring of "${all[j]}"` };
            }
          }
        }

        return { valid: true };
      }
    };

    // Rule-based disguise (fallback)
    function generateDisguiseRuleBased(word) {
      if (!word) return '';
      const lower = word.toLowerCase();
      let disguise = lower
        .replace(/tion$/i, 'shn')
        .replace(/sion$/i, 'zhn')
        .replace(/age$/i, 'j')
        .replace(/dge$/i, 'j')
        .replace(/ght$/i, 't')
        .replace(/ck/g, 'k')
        .replace(/ph/g, 'f')
        .replace(/wh/g, 'w')
        .replace(/wr/g, 'r')
        .replace(/kn/g, 'n')
        .replace(/[aeiou]/g, '');

      if (disguise.length < 2) {
        disguise = lower.replace(/[aeiou](?=[aeiou])/g, '').replace(/[aeiou]$/g, '');
      }
      return disguise || lower.substring(0, 3);
    }

    // LLM-based disguise generation with validation
    async function generateDisguiseLLM(word, existingDisguises = [], maxRetries = 3) {
      const prompt = `Create a phonetic "disguise" for the word "${word}".

Rules:
- Remove or reduce vowels
- Use phonetic shortcuts (tion‚Üíshn, ph‚Üíf, ck‚Üík, etc.)
- Result should SOUND like the word when read aloud
- Keep it 2-8 characters, lowercase letters only
- Example: "garage" ‚Üí "grj", "phone" ‚Üí "fon", "knight" ‚Üí "nyt"

${existingDisguises.length > 0 ? `Avoid these existing disguises: ${existingDisguises.join(', ')}` : ''}

Return ONLY the disguise, nothing else.`;

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const response = await callServer(prompt);
          const disguise = response.trim().toLowerCase().replace(/[^a-z]/g, '');

          const validation = DisguiseValidator.validateAnswerDisguise(disguise, word);
          if (validation.valid && !existingDisguises.includes(disguise)) {
            return disguise;
          }
          console.log(`Disguise attempt ${attempt + 1} rejected: ${disguise} - ${validation.reason || 'duplicate'}`);
        } catch (e) {
          console.log(`Disguise generation failed: ${e.message}`);
        }
      }

      // Fallback to rule-based
      return generateDisguiseRuleBased(word);
    }

    // Generate distractors with validation
    async function generateDistractorsLLM(prompt, answerWord, answerDisguise, maxRetries = 3) {
      const llmPrompt = `Generate 3 distractor disguises for a word puzzle.

The prompt is "${prompt}" and the correct answer is "${answerWord}" (disguised as "${answerDisguise}").

Create 3 WRONG answers that:
1. Look similar to plausible word disguises
2. Are NOT the correct answer or its synonyms
3. Are tempting but wrong guesses
4. Are 2-8 lowercase letters each

For each, provide the disguise and what fake word it might represent.

Format as JSON array:
[{"disguise": "xyz", "fakeWord": "SOMEWORD", "type": "wrong-letters"},...]

Types: "wrong-letters" (plausible but decodes wrong), "non-synonym" (real word, not a synonym)

Return ONLY the JSON array.`;

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const response = await callServer(llmPrompt);
          const jsonMatch = response.match(/\[[\s\S]*\]/);
          if (!jsonMatch) continue;

          const parsed = JSON.parse(jsonMatch[0]);
          const validDistractors = [];
          const usedDisguises = [answerDisguise];

          for (const d of parsed) {
            if (validDistractors.length >= 3) break;
            const disguise = (d.disguise || '').toLowerCase().replace(/[^a-z]/g, '');

            const validation = DisguiseValidator.validateDistractor(
              disguise, answerDisguise, answerWord, prompt, usedDisguises
            );

            if (validation.valid) {
              validDistractors.push({
                word: (d.fakeWord || 'UNKNOWN').toUpperCase(),
                disguise: disguise,
                type: d.type || 'non-synonym'
              });
              usedDisguises.push(disguise);
            } else {
              console.log(`Distractor rejected: ${disguise} - ${validation.reason}`);
            }
          }

          if (validDistractors.length >= 3) {
            // Final validation of the complete set
            const setValidation = DisguiseValidator.validateOptionSet(
              answerDisguise,
              validDistractors.map(d => d.disguise)
            );
            if (setValidation.valid) {
              return validDistractors;
            }
            console.log(`Option set rejected: ${setValidation.reason}`);
          }
        } catch (e) {
          console.log(`Distractor generation attempt ${attempt + 1} failed: ${e.message}`);
        }
      }

      // Fallback: generate rule-based distractors
      return generateDistractorsFallback(answerWord, answerDisguise);
    }

    // Fallback distractor generation
    function generateDistractorsFallback(answerWord, answerDisguise) {
      const variations = [
        answerDisguise.split('').reverse().join(''),
        answerDisguise.slice(0, -1) + 'x',
        'x' + answerDisguise.slice(1),
        answerDisguise.replace(/./g, (c, i) => i === Math.floor(answerDisguise.length/2) ? 'z' : c)
      ].filter(d => d !== answerDisguise && d.length >= 2);

      return variations.slice(0, 3).map((d, i) => ({
        word: 'EDIT_ME',
        disguise: d,
        type: ['wrong-letters', 'non-synonym', 'wrong-letters'][i]
      }));
    }

    // Main disguise function (synchronous, rule-based)
    function generateDisguise(word) {
      return generateDisguiseRuleBased(word);
    }

    // Generate full quiz
    async function generateQuiz() {
      const theme = document.getElementById('themeInput').value.trim();
      if (!theme) {
        alert('Please enter a theme');
        return;
      }

      quiz.theme = theme;
      const container = document.getElementById('questionsContainer');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Generating quiz...</div>';
      document.getElementById('exportSection').classList.add('hidden');

      try {
        if (currentProvider === 'rules') {
          quiz.questions = generateRuleBasedQuiz(theme);
        } else {
          quiz.questions = await generateAIQuiz(theme);
        }
        renderQuestions();
        document.getElementById('exportSection').classList.remove('hidden');
      } catch (error) {
        container.innerHTML = `<div class="empty-state"><h3>Error</h3><p>${error.message}</p></div>`;
      }
    }

    // Rule-based quiz generation (fallback)
    function generateRuleBasedQuiz(theme) {
      const themeData = {
        'buildings': [
          { prompt: 'shed', answer: 'GARAGE', distractors: ['LEAN-TO', 'PORCH', 'SHACK'] },
          { prompt: 'home', answer: 'HOUSE', distractors: ['HUT', 'TENT', 'DOME'] },
          { prompt: 'inn', answer: 'HOTEL', distractors: ['MOTEL', 'HOSTEL', 'LODGE'] },
          { prompt: 'church', answer: 'CHAPEL', distractors: ['TEMPLE', 'SHRINE', 'MOSQUE'] },
          { prompt: 'shop', answer: 'STORE', distractors: ['MARKET', 'MALL', 'BOOTH'] },
          { prompt: 'castle', answer: 'FORTRESS', distractors: ['PALACE', 'MANOR', 'TOWER'] },
        ],
        'emotions': [
          { prompt: 'happy', answer: 'JOYFUL', distractors: ['GLAD', 'MERRY', 'PLEASED'] },
          { prompt: 'sad', answer: 'GLOOMY', distractors: ['MOODY', 'DREARY', 'SOMBER'] },
          { prompt: 'angry', answer: 'FURIOUS', distractors: ['ANNOYED', 'IRATE', 'CROSS'] },
          { prompt: 'scared', answer: 'AFRAID', distractors: ['NERVOUS', 'WORRIED', 'ANXIOUS'] },
          { prompt: 'calm', answer: 'SERENE', distractors: ['PEACEFUL', 'QUIET', 'STILL'] },
          { prompt: 'tired', answer: 'WEARY', distractors: ['SLEEPY', 'DROWSY', 'FATIGUED'] },
        ],
        'weather': [
          { prompt: 'rain', answer: 'SHOWER', distractors: ['DRIZZLE', 'SPRINKLE', 'DOWNPOUR'] },
          { prompt: 'wind', answer: 'BREEZE', distractors: ['GUST', 'DRAFT', 'GALE'] },
          { prompt: 'storm', answer: 'TEMPEST', distractors: ['SQUALL', 'CYCLONE', 'TYPHOON'] },
          { prompt: 'fog', answer: 'MIST', distractors: ['HAZE', 'SMOG', 'VAPOR'] },
          { prompt: 'snow', answer: 'FLURRY', distractors: ['SLEET', 'FROST', 'BLIZZARD'] },
          { prompt: 'sun', answer: 'SHINE', distractors: ['GLOW', 'BEAM', 'GLARE'] },
        ],
      };

      // Find matching theme or use default
      const lowerTheme = theme.toLowerCase();
      let data = null;
      for (const [key, value] of Object.entries(themeData)) {
        if (lowerTheme.includes(key) || key.includes(lowerTheme)) {
          data = value;
          break;
        }
      }

      if (!data) {
        // Generate placeholder data
        data = Array(6).fill(null).map((_, i) => ({
          prompt: `word${i + 1}`,
          answer: `ANSWER${i + 1}`,
          distractors: [`WRONG${i}A`, `WRONG${i}B`, `WRONG${i}C`]
        }));
      }

      return data.map(q => ({
        prompt: q.prompt,
        emoji: '',
        rejectedPrompts: [],
        answer: { word: q.answer, disguise: generateDisguise(q.answer) },
        rejectedAnswers: [],
        distractors: q.distractors.map((d, i) => ({
          word: d,
          disguise: generateDisguise(d),
          type: ['wrong-letters', 'non-synonym', 'non-synonym'][i % 3]
        })),
        rejectedDistractors: []
      }));
    }

    // AI quiz generation
    async function generateAIQuiz(theme) {
      const prompt = `Generate 6 synonym quiz questions for the theme "${theme}".

For each question provide:
1. A prompt word (common word)
2. An answer word (synonym of prompt)
3. Three distractor words with their types (use ONLY these two types):
   - wrong-letters: a plausible-looking consonant pattern that doesn't quite decode to a real word
   - non-synonym: a valid word in the same category but NOT a synonym of the prompt

Format as JSON array:
[
  {
    "prompt": "shed",
    "answer": "GARAGE",
    "distractors": [
      {"word": "LEAN-TO", "type": "wrong-letters"},
      {"word": "PORCH", "type": "non-synonym"},
      {"word": "SHACK", "type": "phonetic-trap"}
    ]
  }
]

Return ONLY the JSON array, no other text.`;

      const response = await callServer(prompt);

      // Parse JSON from response
      let parsed;
      try {
        // Try to extract JSON from response
        const jsonMatch = response.match(/\[[\s\S]*\]/);
        if (jsonMatch) {
          parsed = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (e) {
        console.error('Failed to parse AI response:', response);
        throw new Error('Failed to parse AI response. Try again or use Rule-Based mode.');
      }

      const questions = [];

      for (const q of parsed.slice(0, 6)) {
        const answerWord = (q.answer || '').toUpperCase();
        const promptWord = q.prompt || '';

        // Use LLM for smarter disguises with validation
        const answerDisguise = await generateDisguiseLLM(answerWord);
        const distractors = await generateDistractorsLLM(promptWord, answerWord, answerDisguise);

        questions.push({
          prompt: promptWord,
          emoji: '',
          rejectedPrompts: [],
          answer: {
            word: answerWord,
            disguise: answerDisguise
          },
          rejectedAnswers: [],
          distractors: distractors,
          rejectedDistractors: []
        });
      }

      return questions;
    }

    // Render all questions
    function renderQuestions() {
      const container = document.getElementById('questionsContainer');
      container.innerHTML = quiz.questions.map((q, i) => renderQuestionCard(q, i)).join('');
    }

    // Render single question card
    function renderQuestionCard(q, index) {
      return `
        <div class="question-card" id="question-${index}">
          <h3><span class="num">${index + 1}</span> Question</h3>

          <div class="field-row">
            <label>Prompt:</label>
            <div class="emoji-picker-container">
              <button type="button" class="emoji-btn" onclick="toggleEmojiPicker(${index})">${q.emoji || '‚ûï'}</button>
              <div class="emoji-dropdown" id="emoji-dropdown-${index}">
                <div class="emoji-search">
                  <input type="text" placeholder="Search emojis..." oninput="filterEmojis(${index}, this.value)" id="emoji-search-${index}">
                </div>
                <div class="emoji-tabs" id="emoji-tabs-${index}">
                  ${Object.entries(emojiCategories).map(([name, cat]) =>
                    `<button type="button" class="emoji-tab ${name === currentEmojiCategory ? 'active' : ''}" onclick="switchEmojiCategory(${index}, '${name}')" title="${name}">${cat.icon}</button>`
                  ).join('')}
                </div>
                <div class="emoji-grid-container" id="emoji-grid-${index}">
                  ${renderEmojiGrid(index)}
                </div>
                <div class="emoji-footer">
                  <button type="button" class="emoji-clear" onclick="selectEmoji(${index}, '')">Clear</button>
                  <input type="text" class="emoji-direct-input" placeholder="Paste any emoji" id="emoji-direct-${index}" onkeydown="handleDirectEmoji(event, ${index})" maxlength="2">
                </div>
              </div>
            </div>
            <input type="text" value="${q.prompt}" onchange="updatePrompt(${index}, this.value)" />
            <button class="small" onclick="reshufflePrompt(${index})">üîÑ</button>
          </div>

          <div class="field-row">
            <label>Answer:</label>
            <input type="text" value="${q.answer.word}" onchange="updateAnswer(${index}, this.value)" />
            <input type="text" class="disguise-input" value="${q.answer.disguise}" onchange="updateAnswerDisguise(${index}, this.value)" title="Edit clue" />
            <button class="small" onclick="reshuffleAnswer(${index})">üîÑ</button>
          </div>

          <div class="distractors-section">
            <div class="distractors-header">
              <label>Distractors:</label>
              <button class="small secondary" onclick="reshuffleAllDistractors(${index})">üîÑ All</button>
            </div>
            ${q.distractors.map((d, di) => `
              <div class="field-row">
                <input type="text" value="${d.word}" onchange="updateDistractor(${index}, ${di}, this.value)" style="flex:1" />
                <input type="text" class="disguise-input" value="${d.disguise}" onchange="updateDistractorDisguise(${index}, ${di}, this.value)" title="Edit clue" />
                <span class="type-badge clickable ${d.type}" onclick="cycleType(${index}, ${di})" title="Click to change type">${d.type}</span>
                <button class="small" onclick="reshuffleDistractor(${index}, ${di})">üîÑ</button>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    // Emoji picker functions
    function renderEmojiGrid(qIndex, searchQuery = '') {
      if (searchQuery) {
        // Search across all categories
        const results = [];
        Object.values(emojiCategories).forEach(cat => {
          cat.emojis.forEach(e => {
            if (results.length < 64) results.push(e);
          });
        });
        // Filter by search - for simplicity, just show all emojis and let user scroll
        // A real implementation would use emoji names/keywords
        const filtered = results.slice(0, 64);
        if (filtered.length === 0) {
          return '<div class="emoji-no-results">No emojis found</div>';
        }
        return `
          <div class="emoji-grid">
            ${filtered.map(e => `<button type="button" class="emoji-option" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
          </div>
        `;
      }

      // Show recent emojis if any
      let html = '';
      if (recentEmojis.length > 0) {
        html += `
          <div class="emoji-section-label">Recent</div>
          <div class="emoji-grid">
            ${recentEmojis.slice(0, 16).map(e => `<button type="button" class="emoji-option" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
          </div>
        `;
      }

      // Show current category
      const cat = emojiCategories[currentEmojiCategory];
      if (cat) {
        html += `
          <div class="emoji-section-label">${currentEmojiCategory}</div>
          <div class="emoji-grid">
            ${cat.emojis.map(e => `<button type="button" class="emoji-option" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
          </div>
        `;
      }

      return html;
    }

    function toggleEmojiPicker(qIndex) {
      // Close any other open pickers
      document.querySelectorAll('.emoji-dropdown.open').forEach(el => {
        if (el.id !== `emoji-dropdown-${qIndex}`) {
          el.classList.remove('open');
        }
      });
      const dropdown = document.getElementById(`emoji-dropdown-${qIndex}`);
      const isOpening = !dropdown.classList.contains('open');
      dropdown.classList.toggle('open');

      // Reset search when opening
      if (isOpening) {
        const searchInput = document.getElementById(`emoji-search-${qIndex}`);
        if (searchInput) {
          searchInput.value = '';
          emojiSearchQuery = '';
        }
        updateEmojiGrid(qIndex);
      }
    }

    function switchEmojiCategory(qIndex, category) {
      currentEmojiCategory = category;
      // Update active tab
      const tabsContainer = document.getElementById(`emoji-tabs-${qIndex}`);
      tabsContainer.querySelectorAll('.emoji-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      // Clear search
      const searchInput = document.getElementById(`emoji-search-${qIndex}`);
      if (searchInput) searchInput.value = '';
      emojiSearchQuery = '';
      // Update grid
      updateEmojiGrid(qIndex);
    }

    function filterEmojis(qIndex, query) {
      emojiSearchQuery = query.toLowerCase();
      updateEmojiGrid(qIndex);
    }

    function updateEmojiGrid(qIndex) {
      const gridContainer = document.getElementById(`emoji-grid-${qIndex}`);
      if (gridContainer) {
        gridContainer.innerHTML = renderEmojiGrid(qIndex, emojiSearchQuery);
      }
    }

    function selectEmoji(qIndex, emoji) {
      quiz.questions[qIndex].emoji = emoji;
      document.getElementById(`emoji-dropdown-${qIndex}`).classList.remove('open');

      // Add to recent emojis
      if (emoji) {
        recentEmojis = [emoji, ...recentEmojis.filter(e => e !== emoji)].slice(0, 16);
        localStorage.setItem('cnmn-recent-emojis', JSON.stringify(recentEmojis));
      }

      renderQuestions();
    }

    function handleDirectEmoji(event, qIndex) {
      if (event.key === 'Enter') {
        const input = document.getElementById(`emoji-direct-${qIndex}`);
        const emoji = input.value.trim();
        if (emoji) {
          selectEmoji(qIndex, emoji);
        }
      }
    }

    // Close emoji picker when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.emoji-picker-container')) {
        document.querySelectorAll('.emoji-dropdown.open').forEach(el => {
          el.classList.remove('open');
        });
      }
    });

    // Update functions
    function updatePrompt(qIndex, value) {
      quiz.questions[qIndex].prompt = value.toLowerCase();
    }

    function updateAnswer(qIndex, value) {
      const word = value.toUpperCase();
      quiz.questions[qIndex].answer = {
        word: word,
        disguise: generateDisguise(word)
      };
      renderQuestions();
    }

    function updateDistractor(qIndex, dIndex, value) {
      const word = value.toUpperCase();
      quiz.questions[qIndex].distractors[dIndex].word = word;
      quiz.questions[qIndex].distractors[dIndex].disguise = generateDisguise(word);
      renderQuestions();
    }

    function updateAnswerDisguise(qIndex, value) {
      quiz.questions[qIndex].answer.disguise = value.toLowerCase();
    }

    function updateDistractorDisguise(qIndex, dIndex, value) {
      quiz.questions[qIndex].distractors[dIndex].disguise = value.toLowerCase();
    }

    function cycleType(qIndex, dIndex) {
      const types = ['wrong-letters', 'non-synonym', 'phonetic-trap'];
      const d = quiz.questions[qIndex].distractors[dIndex];
      const currentIdx = types.indexOf(d.type);
      d.type = types[(currentIdx + 1) % types.length];
      renderQuestions();
    }

    // Reshuffle functions
    async function reshufflePrompt(qIndex) {
      const q = quiz.questions[qIndex];
      q.rejectedPrompts.push(q.prompt);

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentProvider === 'rules') {
          q.prompt = `newprompt${qIndex + 1}`;
        } else {
          const prompt = `Give me ONE different word related to "${quiz.theme}" that could be used as a quiz prompt.
Avoid these words: ${q.rejectedPrompts.join(', ')}
Return ONLY the single word, nothing else.`;
          const response = await callServer(prompt);
          q.prompt = response.trim().toLowerCase().replace(/[^a-z]/g, '');
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ';
    }

    async function reshuffleAnswer(qIndex) {
      const q = quiz.questions[qIndex];
      q.rejectedAnswers.push(q.answer.word);

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentProvider === 'rules') {
          q.answer = { word: `NEWANS${qIndex + 1}`, disguise: generateDisguise(`NEWANS${qIndex + 1}`) };
        } else {
          const prompt = `Give me ONE synonym for "${q.prompt}".
Avoid these words: ${q.rejectedAnswers.join(', ')}
Return ONLY the single word in UPPERCASE, nothing else.`;
          const response = await callServer(prompt);
          const word = response.trim().toUpperCase().replace(/[^A-Z]/g, '');
          q.answer = { word, disguise: generateDisguise(word) };
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ';
    }

    async function reshuffleDistractor(qIndex, dIndex) {
      const q = quiz.questions[qIndex];
      const d = q.distractors[dIndex];
      q.rejectedDistractors.push(d.word);

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentProvider === 'rules') {
          d.word = `NEWDIST${qIndex}${dIndex}`;
          d.disguise = generateDisguise(d.word);
        } else {
          const existingWords = [q.answer.word, q.prompt.toUpperCase(), ...q.distractors.map(x => x.word), ...q.rejectedDistractors];
          const prompt = `Give me ONE distractor word for a synonym quiz.
The prompt is "${q.prompt}" and the answer is "${q.answer.word}".
The distractor type should be: ${d.type === 'phonetic-trap' ? 'non-synonym' : d.type}
- wrong-letters: consonant pattern slightly off from a plausible word
- non-synonym: valid word in same category but not a synonym

Avoid these words: ${existingWords.join(', ')}
Return ONLY the single word in UPPERCASE, nothing else.`;
          const response = await callServer(prompt);
          let newWord = response.trim().toUpperCase().replace(/[^A-Z]/g, '');
          // Validate it's not the answer or prompt
          if (newWord === q.answer.word || newWord === q.prompt.toUpperCase()) {
            throw new Error('AI suggested the answer/prompt. Try again.');
          }
          d.word = newWord;
          d.disguise = generateDisguise(d.word);
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ';
    }

    async function reshuffleAllDistractors(qIndex) {
      const q = quiz.questions[qIndex];
      q.rejectedDistractors.push(...q.distractors.map(d => d.word));

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentProvider === 'rules') {
          q.distractors = [
            { word: `NEW${qIndex}A`, disguise: generateDisguise(`NEW${qIndex}A`), type: 'wrong-letters' },
            { word: `NEW${qIndex}B`, disguise: generateDisguise(`NEW${qIndex}B`), type: 'non-synonym' },
            { word: `NEW${qIndex}C`, disguise: generateDisguise(`NEW${qIndex}C`), type: 'phonetic-trap' },
          ];
        } else {
          const prompt = `Generate 3 distractor words for a synonym quiz.
The prompt is "${q.prompt}" and the answer is "${q.answer.word}".

Provide exactly 3 distractors with types (use ONLY these two types):
1. wrong-letters: consonant pattern slightly off from a plausible word
2. non-synonym: valid word in same category but not a synonym
Mix of types is fine. Use whichever fits best for each distractor.

Avoid these words: ${[q.answer.word, q.prompt.toUpperCase(), ...q.rejectedDistractors].join(', ')}

Format as JSON array: [{"word": "WORD", "type": "type"}]
Return ONLY the JSON array.`;
          const response = await callServer(prompt);
          const jsonMatch = response.match(/\[[\s\S]*\]/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            const forbidden = [q.answer.word, q.prompt.toUpperCase()];
            q.distractors = parsed.slice(0, 3)
              .map(d => ({
                word: (d.word || '').toUpperCase(),
                disguise: generateDisguise(d.word || ''),
                type: d.type || 'non-synonym'
              }))
              .filter(d => !forbidden.includes(d.word));
            // Pad if some were filtered
            while (q.distractors.length < 3) {
              q.distractors.push({ word: 'EDIT_ME', disguise: 'dtm', type: 'non-synonym' });
            }
          }
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ All';
    }

    // Build output JSON
    function buildQuizJSON() {
      const pubDate = document.getElementById('pubDate').value;
      return {
        theme: quiz.theme,
        publicationDate: pubDate,
        questions: quiz.questions.map(q => ({
          prompt: q.prompt,
          emoji: q.emoji || '',
          answer: q.answer.word,
          answerDisguise: q.answer.disguise,
          distractors: q.distractors.map(d => ({
            word: d.word,
            disguise: d.disguise,
            type: d.type
          }))
        }))
      };
    }

    // Export to clipboard
    function exportQuiz() {
      const output = buildQuizJSON();
      const json = JSON.stringify(output, null, 2);
      navigator.clipboard.writeText(json).then(() => {
        alert('Quiz JSON copied to clipboard!');
      }).catch(() => {
        prompt('Copy this JSON:', json);
      });
    }

    // Save to filesystem
    async function saveQuiz() {
      const pubDate = document.getElementById('pubDate').value;
      if (!pubDate) {
        alert('Please set a publication date');
        return;
      }

      const output = buildQuizJSON();

      try {
        const response = await fetch('/api/save-puzzle', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(output)
        });

        const result = await response.json();
        if (response.ok) {
          alert(`Saved to ${result.filename}`);
        } else {
          alert('Save failed: ' + result.error);
        }
      } catch (e) {
        alert('Save failed: ' + e.message);
      }
    }

    function clearQuiz() {
      if (confirm('Clear all questions?')) {
        quiz = { theme: '', questions: [] };
        document.getElementById('themeInput').value = '';
        document.getElementById('questionsContainer').innerHTML = `
          <div class="empty-state">
            <h3>No quiz generated yet</h3>
            <p>Enter a theme above and click "Generate 6 Questions"</p>
          </div>
        `;
        document.getElementById('exportSection').classList.add('hidden');
      }
    }

    // API call
    async function callServer(prompt) {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ provider: currentProvider, prompt })
      });

      const data = await response.json();
      if (!response.ok || data.error) {
        throw new Error(data.error || 'Server error');
      }
      return data.content;
    }

    // Initialize
    loadProviders();
  </script>
</body>
</html>
