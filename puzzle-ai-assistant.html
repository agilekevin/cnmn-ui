<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cnmn Quiz Generator</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(165deg, #fdfbf7 0%, #f5e6d3 50%, #ecdbc8 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    h1 {
      color: #6b3410;
      margin-bottom: 10px;
      font-size: 28px;
      letter-spacing: 2px;
    }

    .subtitle {
      color: #8b6340;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 4px 20px rgba(107, 52, 16, 0.1);
      margin-bottom: 20px;
    }

    .panel h2 {
      color: #6b3410;
      margin-bottom: 16px;
      font-size: 18px;
    }

    .form-row {
      display: flex;
      gap: 12px;
      align-items: end;
      margin-bottom: 16px;
    }

    .form-group {
      flex: 1;
    }

    label {
      display: block;
      margin-bottom: 6px;
      color: #6b3410;
      font-weight: 600;
      font-size: 13px;
    }

    input[type="text"], select {
      width: 100%;
      padding: 10px 12px;
      border: 2px solid #c4a574;
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #6b3410;
    }

    button {
      background: #6b3410;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    button:hover {
      background: #8b4513;
    }

    button:disabled {
      background: #c4a574;
      cursor: not-allowed;
    }

    button.small {
      padding: 6px 10px;
      font-size: 12px;
    }

    button.secondary {
      background: #8b6340;
    }

    button.export {
      background: #2e7d32;
    }

    button.export:hover {
      background: #388e3c;
    }

    .hint {
      font-size: 12px;
      color: #8b6340;
      margin-top: 4px;
      font-style: italic;
    }

    /* Provider selection */
    .provider-bar {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 2px solid #ecdbc8;
    }

    .provider-btn {
      padding: 8px 16px;
      border: 2px solid #c4a574;
      background: white;
      color: #6b3410;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
    }

    .provider-btn:hover {
      border-color: #6b3410;
    }

    .provider-btn.selected {
      background: #6b3410;
      color: white;
      border-color: #6b3410;
    }

    .provider-btn.unavailable {
      opacity: 0.4;
      pointer-events: none;
    }

    .provider-status {
      font-size: 12px;
      color: #8b6340;
      margin-left: auto;
      align-self: center;
    }

    /* Question cards */
    .questions-grid {
      display: grid;
      gap: 16px;
    }

    .question-card {
      background: white;
      border: 2px solid #ecdbc8;
      border-radius: 12px;
      padding: 16px;
    }

    .question-card h3 {
      color: #6b3410;
      font-size: 14px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .question-card h3 .num {
      background: #6b3410;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .field-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    .field-row label {
      width: 70px;
      margin: 0;
      font-size: 12px;
    }

    .field-row input {
      flex: 1;
      padding: 6px 10px;
      font-size: 13px;
    }

    .disguise-preview {
      font-family: 'Courier New', monospace;
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      min-width: 60px;
      text-align: center;
    }

    .type-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      background: #ecdbc8;
      color: #6b3410;
      white-space: nowrap;
    }

    .type-badge.wrong-letters { background: #ffcdd2; color: #c62828; }
    .type-badge.non-synonym { background: #fff3e0; color: #e65100; }
    .type-badge.phonetic-trap { background: #e3f2fd; color: #1565c0; }

    .type-badge.clickable {
      cursor: pointer;
    }
    .type-badge.clickable:hover {
      opacity: 0.8;
    }

    .distractors-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #ecdbc8;
    }

    .distractors-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .distractors-header label {
      font-size: 12px;
      margin: 0;
    }

    /* Loading state */
    .loading {
      text-align: center;
      padding: 40px;
      color: #8b6340;
    }

    .spinner {
      border: 3px solid #ecdbc8;
      border-top: 3px solid #6b3410;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Hidden */
    .hidden {
      display: none !important;
    }

    /* Export section */
    .export-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid #ecdbc8;
      display: flex;
      gap: 12px;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #8b6340;
    }

    .empty-state h3 {
      color: #6b3410;
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>cnmn Quiz Generator</h1>
    <p class="subtitle">Generate themed synonym puzzles with phonetic disguises</p>

    <!-- Provider Selection -->
    <div class="panel">
      <div class="provider-bar">
        <button class="provider-btn selected" data-provider="openai" onclick="selectProvider('openai')">OpenAI</button>
        <button class="provider-btn" data-provider="anthropic" onclick="selectProvider('anthropic')">Anthropic</button>
        <button class="provider-btn" data-provider="rules" onclick="selectProvider('rules')">Rule-Based</button>
        <span class="provider-status" id="providerStatus">Checking...</span>
      </div>

      <div class="form-row">
        <div class="form-group">
          <label>Theme</label>
          <input type="text" id="themeInput" placeholder="e.g., Buildings, Emotions, Weather, Animals">
        </div>
        <div class="form-group" style="max-width: 180px;">
          <label>Publication Date</label>
          <input type="date" id="pubDate">
        </div>
        <button onclick="generateQuiz()" id="generateBtn">Generate 6 Questions</button>
      </div>
      <p class="hint">Enter a theme and publication date to generate 6 synonym quiz questions.</p>
    </div>

    <!-- Questions -->
    <div class="panel" id="questionsPanel">
      <h2>Quiz Questions</h2>

      <div id="questionsContainer">
        <div class="empty-state">
          <h3>No quiz generated yet</h3>
          <p>Enter a theme above and click "Generate 6 Questions"</p>
        </div>
      </div>

      <div class="export-section hidden" id="exportSection">
        <button class="export" onclick="saveQuiz()">üíæ Save Puzzle</button>
        <button class="secondary" onclick="exportQuiz()">üìã Copy JSON</button>
        <button class="secondary" onclick="clearQuiz()">üóëÔ∏è Clear</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let currentProvider = 'openai';
    let availableProviders = { openai: false, anthropic: false };
    let quiz = {
      theme: '',
      publicationDate: '',
      questions: []  // Array of 6 question objects
    };

    // Initialize date picker to tomorrow
    document.addEventListener('DOMContentLoaded', () => {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      document.getElementById('pubDate').value = tomorrow.toISOString().split('T')[0];
    });

    // Question structure:
    // {
    //   prompt: "shed",
    //   rejectedPrompts: [],
    //   answer: { word: "GARAGE", disguise: "grj" },
    //   rejectedAnswers: [],
    //   distractors: [
    //     { word: "LEAN-TO", disguise: "lntso", type: "wrong-letters" },
    //     { word: "PORCH", disguise: "prch", type: "non-synonym" },
    //     { word: "SHACK", disguise: "chk", type: "phonetic-trap" }
    //   ],
    //   rejectedDistractors: []
    // }

    // Load providers
    async function loadProviders() {
      const status = document.getElementById('providerStatus');
      try {
        const response = await fetch('/api/providers');
        availableProviders = await response.json();

        document.querySelectorAll('.provider-btn').forEach(btn => {
          const provider = btn.dataset.provider;
          if (provider === 'rules') return;
          if (!availableProviders[provider]) {
            btn.classList.add('unavailable');
          }
        });

        const available = [];
        if (availableProviders.openai) available.push('OpenAI');
        if (availableProviders.anthropic) available.push('Anthropic');

        if (available.length > 0) {
          status.textContent = `Available: ${available.join(', ')}`;
          if (availableProviders.openai) selectProvider('openai');
          else if (availableProviders.anthropic) selectProvider('anthropic');
          else selectProvider('rules');
        } else {
          status.textContent = 'No AI configured - using rules';
          selectProvider('rules');
        }
      } catch (e) {
        status.textContent = 'Server offline - using rules';
        document.querySelector('[data-provider="openai"]').classList.add('unavailable');
        document.querySelector('[data-provider="anthropic"]').classList.add('unavailable');
        selectProvider('rules');
      }
    }

    function selectProvider(provider) {
      currentProvider = provider;
      document.querySelectorAll('.provider-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.provider === provider);
      });
    }

    // Disguise generation (rule-based)
    function generateDisguise(word) {
      if (!word) return '';
      const lower = word.toLowerCase();
      // Remove vowels, apply phonetic simplifications
      let disguise = lower
        .replace(/tion$/i, 'shn')
        .replace(/sion$/i, 'zhn')
        .replace(/age$/i, 'j')
        .replace(/dge$/i, 'j')
        .replace(/ght$/i, 't')
        .replace(/ck/g, 'k')
        .replace(/ph/g, 'f')
        .replace(/wh/g, 'w')
        .replace(/wr/g, 'r')
        .replace(/kn/g, 'n')
        .replace(/[aeiou]/g, '');

      // Ensure minimum length
      if (disguise.length < 2) {
        disguise = lower.replace(/[aeiou](?=[aeiou])/g, '').replace(/[aeiou]$/g, '');
      }
      return disguise || lower.substring(0, 3);
    }

    // Generate full quiz
    async function generateQuiz() {
      const theme = document.getElementById('themeInput').value.trim();
      if (!theme) {
        alert('Please enter a theme');
        return;
      }

      quiz.theme = theme;
      const container = document.getElementById('questionsContainer');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Generating quiz...</div>';
      document.getElementById('exportSection').classList.add('hidden');

      try {
        if (currentProvider === 'rules') {
          quiz.questions = generateRuleBasedQuiz(theme);
        } else {
          quiz.questions = await generateAIQuiz(theme);
        }
        renderQuestions();
        document.getElementById('exportSection').classList.remove('hidden');
      } catch (error) {
        container.innerHTML = `<div class="empty-state"><h3>Error</h3><p>${error.message}</p></div>`;
      }
    }

    // Rule-based quiz generation (fallback)
    function generateRuleBasedQuiz(theme) {
      const themeData = {
        'buildings': [
          { prompt: 'shed', answer: 'GARAGE', distractors: ['LEAN-TO', 'PORCH', 'SHACK'] },
          { prompt: 'home', answer: 'HOUSE', distractors: ['HUT', 'TENT', 'DOME'] },
          { prompt: 'inn', answer: 'HOTEL', distractors: ['MOTEL', 'HOSTEL', 'LODGE'] },
          { prompt: 'church', answer: 'CHAPEL', distractors: ['TEMPLE', 'SHRINE', 'MOSQUE'] },
          { prompt: 'shop', answer: 'STORE', distractors: ['MARKET', 'MALL', 'BOOTH'] },
          { prompt: 'castle', answer: 'FORTRESS', distractors: ['PALACE', 'MANOR', 'TOWER'] },
        ],
        'emotions': [
          { prompt: 'happy', answer: 'JOYFUL', distractors: ['GLAD', 'MERRY', 'PLEASED'] },
          { prompt: 'sad', answer: 'GLOOMY', distractors: ['MOODY', 'DREARY', 'SOMBER'] },
          { prompt: 'angry', answer: 'FURIOUS', distractors: ['ANNOYED', 'IRATE', 'CROSS'] },
          { prompt: 'scared', answer: 'AFRAID', distractors: ['NERVOUS', 'WORRIED', 'ANXIOUS'] },
          { prompt: 'calm', answer: 'SERENE', distractors: ['PEACEFUL', 'QUIET', 'STILL'] },
          { prompt: 'tired', answer: 'WEARY', distractors: ['SLEEPY', 'DROWSY', 'FATIGUED'] },
        ],
        'weather': [
          { prompt: 'rain', answer: 'SHOWER', distractors: ['DRIZZLE', 'SPRINKLE', 'DOWNPOUR'] },
          { prompt: 'wind', answer: 'BREEZE', distractors: ['GUST', 'DRAFT', 'GALE'] },
          { prompt: 'storm', answer: 'TEMPEST', distractors: ['SQUALL', 'CYCLONE', 'TYPHOON'] },
          { prompt: 'fog', answer: 'MIST', distractors: ['HAZE', 'SMOG', 'VAPOR'] },
          { prompt: 'snow', answer: 'FLURRY', distractors: ['SLEET', 'FROST', 'BLIZZARD'] },
          { prompt: 'sun', answer: 'SHINE', distractors: ['GLOW', 'BEAM', 'GLARE'] },
        ],
      };

      // Find matching theme or use default
      const lowerTheme = theme.toLowerCase();
      let data = null;
      for (const [key, value] of Object.entries(themeData)) {
        if (lowerTheme.includes(key) || key.includes(lowerTheme)) {
          data = value;
          break;
        }
      }

      if (!data) {
        // Generate placeholder data
        data = Array(6).fill(null).map((_, i) => ({
          prompt: `word${i + 1}`,
          answer: `ANSWER${i + 1}`,
          distractors: [`WRONG${i}A`, `WRONG${i}B`, `WRONG${i}C`]
        }));
      }

      return data.map(q => ({
        prompt: q.prompt,
        rejectedPrompts: [],
        answer: { word: q.answer, disguise: generateDisguise(q.answer) },
        rejectedAnswers: [],
        distractors: q.distractors.map((d, i) => ({
          word: d,
          disguise: generateDisguise(d),
          type: ['wrong-letters', 'non-synonym', 'non-synonym'][i % 3]
        })),
        rejectedDistractors: []
      }));
    }

    // AI quiz generation
    async function generateAIQuiz(theme) {
      const prompt = `Generate 6 synonym quiz questions for the theme "${theme}".

For each question provide:
1. A prompt word (common word)
2. An answer word (synonym of prompt)
3. Three distractor words with their types (use ONLY these two types):
   - wrong-letters: a plausible-looking consonant pattern that doesn't quite decode to a real word
   - non-synonym: a valid word in the same category but NOT a synonym of the prompt

Format as JSON array:
[
  {
    "prompt": "shed",
    "answer": "GARAGE",
    "distractors": [
      {"word": "LEAN-TO", "type": "wrong-letters"},
      {"word": "PORCH", "type": "non-synonym"},
      {"word": "SHACK", "type": "phonetic-trap"}
    ]
  }
]

Return ONLY the JSON array, no other text.`;

      const response = await callServer(prompt);

      // Parse JSON from response
      let parsed;
      try {
        // Try to extract JSON from response
        const jsonMatch = response.match(/\[[\s\S]*\]/);
        if (jsonMatch) {
          parsed = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (e) {
        console.error('Failed to parse AI response:', response);
        throw new Error('Failed to parse AI response. Try again or use Rule-Based mode.');
      }

      return parsed.slice(0, 6).map(q => ({
        prompt: q.prompt || '',
        rejectedPrompts: [],
        answer: {
          word: (q.answer || '').toUpperCase(),
          disguise: generateDisguise(q.answer || '')
        },
        rejectedAnswers: [],
        distractors: (q.distractors || []).slice(0, 3).map(d => ({
          word: (d.word || '').toUpperCase(),
          disguise: generateDisguise(d.word || ''),
          type: d.type || 'non-synonym'
        })),
        rejectedDistractors: []
      }));
    }

    // Render all questions
    function renderQuestions() {
      const container = document.getElementById('questionsContainer');
      container.innerHTML = quiz.questions.map((q, i) => renderQuestionCard(q, i)).join('');
    }

    // Render single question card
    function renderQuestionCard(q, index) {
      return `
        <div class="question-card" id="question-${index}">
          <h3><span class="num">${index + 1}</span> Question</h3>

          <div class="field-row">
            <label>Prompt:</label>
            <input type="text" value="${q.prompt}" onchange="updatePrompt(${index}, this.value)" />
            <button class="small" onclick="reshufflePrompt(${index})">üîÑ</button>
          </div>

          <div class="field-row">
            <label>Answer:</label>
            <input type="text" value="${q.answer.word}" onchange="updateAnswer(${index}, this.value)" />
            <span class="disguise-preview">${q.answer.disguise}</span>
            <button class="small" onclick="reshuffleAnswer(${index})">üîÑ</button>
          </div>

          <div class="distractors-section">
            <div class="distractors-header">
              <label>Distractors:</label>
              <button class="small secondary" onclick="reshuffleAllDistractors(${index})">üîÑ All</button>
            </div>
            ${q.distractors.map((d, di) => `
              <div class="field-row">
                <input type="text" value="${d.word}" onchange="updateDistractor(${index}, ${di}, this.value)" style="flex:1" />
                <span class="disguise-preview">${d.disguise}</span>
                <span class="type-badge clickable ${d.type}" onclick="cycleType(${index}, ${di})" title="Click to change type">${d.type}</span>
                <button class="small" onclick="reshuffleDistractor(${index}, ${di})">üîÑ</button>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    // Update functions
    function updatePrompt(qIndex, value) {
      quiz.questions[qIndex].prompt = value.toLowerCase();
    }

    function updateAnswer(qIndex, value) {
      const word = value.toUpperCase();
      quiz.questions[qIndex].answer = {
        word: word,
        disguise: generateDisguise(word)
      };
      renderQuestions();
    }

    function updateDistractor(qIndex, dIndex, value) {
      const word = value.toUpperCase();
      quiz.questions[qIndex].distractors[dIndex].word = word;
      quiz.questions[qIndex].distractors[dIndex].disguise = generateDisguise(word);
      renderQuestions();
    }

    function cycleType(qIndex, dIndex) {
      const types = ['wrong-letters', 'non-synonym', 'phonetic-trap'];
      const d = quiz.questions[qIndex].distractors[dIndex];
      const currentIdx = types.indexOf(d.type);
      d.type = types[(currentIdx + 1) % types.length];
      renderQuestions();
    }

    // Reshuffle functions
    async function reshufflePrompt(qIndex) {
      const q = quiz.questions[qIndex];
      q.rejectedPrompts.push(q.prompt);

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentProvider === 'rules') {
          q.prompt = `newprompt${qIndex + 1}`;
        } else {
          const prompt = `Give me ONE different word related to "${quiz.theme}" that could be used as a quiz prompt.
Avoid these words: ${q.rejectedPrompts.join(', ')}
Return ONLY the single word, nothing else.`;
          const response = await callServer(prompt);
          q.prompt = response.trim().toLowerCase().replace(/[^a-z]/g, '');
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ';
    }

    async function reshuffleAnswer(qIndex) {
      const q = quiz.questions[qIndex];
      q.rejectedAnswers.push(q.answer.word);

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentProvider === 'rules') {
          q.answer = { word: `NEWANS${qIndex + 1}`, disguise: generateDisguise(`NEWANS${qIndex + 1}`) };
        } else {
          const prompt = `Give me ONE synonym for "${q.prompt}".
Avoid these words: ${q.rejectedAnswers.join(', ')}
Return ONLY the single word in UPPERCASE, nothing else.`;
          const response = await callServer(prompt);
          const word = response.trim().toUpperCase().replace(/[^A-Z]/g, '');
          q.answer = { word, disguise: generateDisguise(word) };
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ';
    }

    async function reshuffleDistractor(qIndex, dIndex) {
      const q = quiz.questions[qIndex];
      const d = q.distractors[dIndex];
      q.rejectedDistractors.push(d.word);

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentProvider === 'rules') {
          d.word = `NEWDIST${qIndex}${dIndex}`;
          d.disguise = generateDisguise(d.word);
        } else {
          const existingWords = [q.answer.word, q.prompt.toUpperCase(), ...q.distractors.map(x => x.word), ...q.rejectedDistractors];
          const prompt = `Give me ONE distractor word for a synonym quiz.
The prompt is "${q.prompt}" and the answer is "${q.answer.word}".
The distractor type should be: ${d.type === 'phonetic-trap' ? 'non-synonym' : d.type}
- wrong-letters: consonant pattern slightly off from a plausible word
- non-synonym: valid word in same category but not a synonym

Avoid these words: ${existingWords.join(', ')}
Return ONLY the single word in UPPERCASE, nothing else.`;
          const response = await callServer(prompt);
          let newWord = response.trim().toUpperCase().replace(/[^A-Z]/g, '');
          // Validate it's not the answer or prompt
          if (newWord === q.answer.word || newWord === q.prompt.toUpperCase()) {
            throw new Error('AI suggested the answer/prompt. Try again.');
          }
          d.word = newWord;
          d.disguise = generateDisguise(d.word);
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ';
    }

    async function reshuffleAllDistractors(qIndex) {
      const q = quiz.questions[qIndex];
      q.rejectedDistractors.push(...q.distractors.map(d => d.word));

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentProvider === 'rules') {
          q.distractors = [
            { word: `NEW${qIndex}A`, disguise: generateDisguise(`NEW${qIndex}A`), type: 'wrong-letters' },
            { word: `NEW${qIndex}B`, disguise: generateDisguise(`NEW${qIndex}B`), type: 'non-synonym' },
            { word: `NEW${qIndex}C`, disguise: generateDisguise(`NEW${qIndex}C`), type: 'phonetic-trap' },
          ];
        } else {
          const prompt = `Generate 3 distractor words for a synonym quiz.
The prompt is "${q.prompt}" and the answer is "${q.answer.word}".

Provide exactly 3 distractors with types (use ONLY these two types):
1. wrong-letters: consonant pattern slightly off from a plausible word
2. non-synonym: valid word in same category but not a synonym
Mix of types is fine. Use whichever fits best for each distractor.

Avoid these words: ${[q.answer.word, q.prompt.toUpperCase(), ...q.rejectedDistractors].join(', ')}

Format as JSON array: [{"word": "WORD", "type": "type"}]
Return ONLY the JSON array.`;
          const response = await callServer(prompt);
          const jsonMatch = response.match(/\[[\s\S]*\]/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            const forbidden = [q.answer.word, q.prompt.toUpperCase()];
            q.distractors = parsed.slice(0, 3)
              .map(d => ({
                word: (d.word || '').toUpperCase(),
                disguise: generateDisguise(d.word || ''),
                type: d.type || 'non-synonym'
              }))
              .filter(d => !forbidden.includes(d.word));
            // Pad if some were filtered
            while (q.distractors.length < 3) {
              q.distractors.push({ word: 'EDIT_ME', disguise: 'dtm', type: 'non-synonym' });
            }
          }
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ All';
    }

    // Build output JSON
    function buildQuizJSON() {
      const pubDate = document.getElementById('pubDate').value;
      return {
        theme: quiz.theme,
        publicationDate: pubDate,
        questions: quiz.questions.map(q => ({
          prompt: q.prompt,
          answer: q.answer.word,
          answerDisguise: q.answer.disguise,
          distractors: q.distractors.map(d => ({
            word: d.word,
            disguise: d.disguise,
            type: d.type
          }))
        }))
      };
    }

    // Export to clipboard
    function exportQuiz() {
      const output = buildQuizJSON();
      const json = JSON.stringify(output, null, 2);
      navigator.clipboard.writeText(json).then(() => {
        alert('Quiz JSON copied to clipboard!');
      }).catch(() => {
        prompt('Copy this JSON:', json);
      });
    }

    // Save to filesystem
    async function saveQuiz() {
      const pubDate = document.getElementById('pubDate').value;
      if (!pubDate) {
        alert('Please set a publication date');
        return;
      }

      const output = buildQuizJSON();

      try {
        const response = await fetch('/api/save-puzzle', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(output)
        });

        const result = await response.json();
        if (response.ok) {
          alert(`Saved to ${result.filename}`);
        } else {
          alert('Save failed: ' + result.error);
        }
      } catch (e) {
        alert('Save failed: ' + e.message);
      }
    }

    function clearQuiz() {
      if (confirm('Clear all questions?')) {
        quiz = { theme: '', questions: [] };
        document.getElementById('themeInput').value = '';
        document.getElementById('questionsContainer').innerHTML = `
          <div class="empty-state">
            <h3>No quiz generated yet</h3>
            <p>Enter a theme above and click "Generate 6 Questions"</p>
          </div>
        `;
        document.getElementById('exportSection').classList.add('hidden');
      }
    }

    // API call
    async function callServer(prompt) {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ provider: currentProvider, prompt })
      });

      const data = await response.json();
      if (!response.ok || data.error) {
        throw new Error(data.error || 'Server error');
      }
      return data.content;
    }

    // Initialize
    loadProviders();
  </script>
</body>
</html>
