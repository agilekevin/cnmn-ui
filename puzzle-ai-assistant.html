<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cnmn AI Puzzle Assistant</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(165deg, #fdfbf7 0%, #f5e6d3 50%, #ecdbc8 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
    }

    h1 {
      color: #6b3410;
      margin-bottom: 10px;
      font-size: 32px;
      letter-spacing: 2px;
    }

    .subtitle {
      color: #8b6340;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 20px rgba(107, 52, 16, 0.1);
      margin-bottom: 20px;
    }

    .panel h2 {
      color: #6b3410;
      margin-bottom: 20px;
      font-size: 20px;
      border-bottom: 2px solid #ecdbc8;
      padding-bottom: 10px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: #6b3410;
      font-weight: 600;
      font-size: 14px;
    }

    input[type="text"],
    input[type="password"],
    select,
    textarea {
      width: 100%;
      padding: 12px;
      border: 2px solid #c4a574;
      border-radius: 8px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    input:focus,
    select:focus,
    textarea:focus {
      outline: none;
      border-color: #6b3410;
    }

    textarea {
      resize: vertical;
      min-height: 100px;
      font-family: inherit;
    }

    button {
      background: #6b3410;
      color: white;
      border: none;
      padding: 14px 28px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 1px;
      width: 100%;
    }

    button:hover {
      background: #8b4513;
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #c4a574;
      cursor: not-allowed;
      transform: none;
    }

    .hint {
      font-size: 12px;
      color: #8b6340;
      margin-top: 5px;
      font-style: italic;
    }

    .result-box {
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 20px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.8;
      margin-top: 20px;
      white-space: pre-wrap;
      max-height: 500px;
      overflow-y: auto;
      display: none;
    }

    .result-box.show {
      display: block;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #6b3410;
    }

    .spinner {
      border: 3px solid #ecdbc8;
      border-top: 3px solid #6b3410;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 0 auto 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .provider-select {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }

    .provider-option {
      padding: 15px;
      border: 2px solid #c4a574;
      border-radius: 8px;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s;
      background: white;
    }

    .provider-option:hover {
      border-color: #6b3410;
      background: #fdfbf7;
    }

    .provider-option.selected {
      border-color: #6b3410;
      background: #6b3410;
      color: white;
    }

    .provider-option.unavailable {
      opacity: 0.4;
      pointer-events: none;
      display: none;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 15px;
      margin-bottom: 10px;
    }

    .checkbox-group input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #6b3410;
    }

    .checkbox-group label {
      display: inline;
      margin: 0;
      cursor: pointer;
      font-weight: 500;
    }

    .tooltip-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      background: #c4a574;
      color: white;
      border-radius: 50%;
      font-size: 12px;
      font-weight: bold;
      cursor: help;
      position: relative;
    }

    .tooltip-icon:hover .tooltip-text {
      visibility: visible;
      opacity: 1;
    }

    .tooltip-text {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      bottom: 130%;
      left: 50%;
      transform: translateX(-50%);
      width: 280px;
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: normal;
      line-height: 1.5;
      z-index: 100;
      transition: opacity 0.2s;
    }

    .tooltip-text::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: #2d2d2d;
    }

    .provider-option .name {
      font-weight: 600;
      margin-bottom: 5px;
    }

    .provider-option .desc {
      font-size: 11px;
      opacity: 0.8;
    }

    .tabs {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      border-bottom: 2px solid #ecdbc8;
    }

    .tab {
      padding: 12px 24px;
      cursor: pointer;
      border: none;
      background: transparent;
      color: #8b6340;
      font-weight: 600;
      border-bottom: 3px solid transparent;
      transition: all 0.2s;
      width: auto;
      text-transform: none;
      letter-spacing: 0;
    }

    .tab:hover {
      color: #6b3410;
      background: transparent;
      transform: none;
    }

    .tab.active {
      color: #6b3410;
      border-bottom-color: #6b3410;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .example-box {
      background: #fdfbf7;
      border: 2px solid #ecdbc8;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
    }

    .example-box h3 {
      color: #6b3410;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .example-box p {
      color: #8b6340;
      font-size: 13px;
      line-height: 1.6;
    }

    .flow-button {
      background: #2e7d32;
      margin-top: 15px;
    }

    .flow-button:hover {
      background: #388e3c;
    }

    .chain-words {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin: 15px 0;
    }

    .chain-word {
      background: #6b3410;
      color: white;
      padding: 8px 14px;
      border-radius: 20px;
      font-weight: 600;
      font-size: 13px;
    }

    .chain-word.editable {
      background: white;
      color: #6b3410;
      border: 2px solid #6b3410;
      cursor: pointer;
    }

    .chain-word.editable:hover {
      background: #fdfbf7;
    }

    .step-indicator {
      display: flex;
      gap: 10px;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 2px solid #ecdbc8;
    }

    .step {
      display: flex;
      align-items: center;
      gap: 8px;
      color: #c4a574;
      font-size: 13px;
    }

    .step.active {
      color: #6b3410;
      font-weight: 600;
    }

    .step.completed {
      color: #2e7d32;
    }

    .step-num {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: #ecdbc8;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 12px;
    }

    .step.active .step-num {
      background: #6b3410;
      color: white;
    }

    .step.completed .step-num {
      background: #2e7d32;
      color: white;
    }

    .step-arrow {
      color: #c4a574;
    }

    .section-result {
      background: #fdfbf7;
      border: 2px solid #ecdbc8;
      border-radius: 8px;
      padding: 20px;
      margin-top: 20px;
    }

    .section-result h3 {
      color: #6b3410;
      margin-bottom: 15px;
      font-size: 16px;
    }

    .hidden {
      display: none !important;
    }

    .disguise-grid {
      display: grid;
      gap: 15px;
    }

    .disguise-item {
      background: white;
      border: 2px solid #ecdbc8;
      border-radius: 8px;
      padding: 15px;
    }

    .disguise-item .word {
      font-weight: 700;
      color: #6b3410;
      margin-bottom: 8px;
    }

    .disguise-item .variants {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .variant {
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 4px 10px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .variant:hover {
      background: #6b3410;
    }

    .variant.selected {
      background: #2e7d32;
    }

    .validation-result {
      background: white;
      border: 2px solid #ecdbc8;
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
    }

    .validation-result.success {
      border-color: #2e7d32;
    }

    .validation-result.warning {
      border-color: #f57c00;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ü§ñ cnmn AI Puzzle Assistant</h1>
    <p class="subtitle">Get AI help brainstorming puzzle chains and creating phonetic disguises</p>

    <!-- Provider Selection -->
    <div class="panel">
      <h2>‚öôÔ∏è AI Provider</h2>

      <div class="form-group">
        <label>Select AI Provider</label>
        <div class="provider-select" id="providerSelect">
          <div class="provider-option" data-provider="openai" onclick="selectProvider('openai')">
            <div class="name">OpenAI</div>
            <div class="desc">GPT-4</div>
          </div>
          <div class="provider-option" data-provider="anthropic" onclick="selectProvider('anthropic')">
            <div class="name">Anthropic</div>
            <div class="desc">Claude</div>
          </div>
          <div class="provider-option selected" data-provider="rules" onclick="selectProvider('rules')">
            <div class="name">Rule-Based</div>
            <div class="desc">Free, no API needed</div>
          </div>
        </div>
        <div class="hint" id="providerHint">Loading available providers...</div>
      </div>
    </div>

    <!-- Workflow -->
    <div class="panel">
      <h2>üõ†Ô∏è Puzzle Builder</h2>

      <div class="step-indicator">
        <div class="step active" id="step1">
          <span class="step-num">1</span>
          <span>Brainstorm</span>
        </div>
        <span class="step-arrow">‚Üí</span>
        <div class="step" id="step2">
          <span class="step-num">2</span>
          <span>Disguise</span>
        </div>
        <span class="step-arrow">‚Üí</span>
        <div class="step" id="step3">
          <span class="step-num">3</span>
          <span>Validate</span>
        </div>
      </div>

      <!-- Step 1: Brainstorm -->
      <div id="brainstorm-section">
        <div class="example-box">
          <h3>Step 1: Generate a Chain</h3>
          <p>Enter a theme or starting word to generate a 6-word chain with logical connections.</p>
        </div>

        <div class="form-group">
          <label>Theme or Starting Word</label>
          <input type="text" id="brainstormInput" placeholder="e.g., Ocean, Sports, Kitchen Tools" onkeypress="if(event.key==='Enter')brainstormChain()">
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="strictConsistency">
          <label for="strictConsistency">Strict consistency</label>
          <span class="tooltip-icon">?
            <span class="tooltip-text">
              <strong>Strict:</strong> All words stay within the category.<br>
              Example: "kitchen tools" ‚Üí knife, whisk, spatula, grater, peeler, tongs<br><br>
              <strong>Default (off):</strong> Chain can flow between related categories.<br>
              Example: "kitchen tools" ‚Üí knife ‚Üí cut ‚Üí steak ‚Üí cattle ‚Üí ranch
            </span>
          </span>
        </div>

        <button onclick="brainstormChain()">üéØ Generate Chain Ideas</button>

        <div id="brainstormResult" class="result-box"></div>

        <div id="chainPreview" class="section-result hidden">
          <h3>üìã Your Chain</h3>
          <div class="chain-words" id="chainWords"></div>
          <p class="hint">Click a word to edit it, or proceed to create disguises.</p>
          <button class="flow-button" onclick="proceedToDisguises()">üé≠ Create Disguises for This Chain ‚Üí</button>
        </div>
      </div>

      <!-- Step 2: Disguises -->
      <div id="disguise-section" class="hidden">
        <div class="example-box">
          <h3>Step 2: Create Disguises</h3>
          <p>Generating phonetic variants for each word in your chain...</p>
        </div>

        <div class="chain-words" id="chainWordsSmall"></div>

        <div id="disguiseResult" class="disguise-grid"></div>

        <div id="disguiseActions" class="hidden">
          <button onclick="regenerateDisguises()">üîÑ Regenerate Disguises</button>
          <button class="flow-button" onclick="proceedToValidation()">‚úÖ Validate Chain ‚Üí</button>
        </div>
      </div>

      <!-- Step 3: Validation -->
      <div id="validate-section" class="hidden">
        <div class="example-box">
          <h3>Step 3: Validation</h3>
          <p>Checking connection logic and difficulty balance...</p>
        </div>

        <div class="chain-words" id="chainWordsFinal"></div>

        <div id="validateResult" class="validation-result"></div>

        <div id="finalActions" class="hidden" style="margin-top: 20px;">
          <button onclick="copyForGenerator()">üìã Copy for Puzzle Generator</button>
          <button onclick="startOver()">üîÑ Start New Chain</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let currentProvider = 'rules';
    let availableProviders = { openai: false, anthropic: false };
    let currentChain = [];
    let currentDisguises = {};

    // Load available providers from server
    async function loadProviders() {
      const hint = document.getElementById('providerHint');
      try {
        const response = await fetch('/api/providers');
        availableProviders = await response.json();

        console.log('Providers from API:', availableProviders);

        const openaiOption = document.querySelector('[data-provider="openai"]');
        const anthropicOption = document.querySelector('[data-provider="anthropic"]');

        // Mark unavailable providers
        if (availableProviders.openai) {
          openaiOption.classList.remove('unavailable');
        } else {
          openaiOption.classList.add('unavailable');
        }

        if (availableProviders.anthropic) {
          anthropicOption.classList.remove('unavailable');
        } else {
          anthropicOption.classList.add('unavailable');
        }

        const configuredProviders = [];
        if (availableProviders.openai) configuredProviders.push('OpenAI');
        if (availableProviders.anthropic) configuredProviders.push('Anthropic');

        if (configuredProviders.length > 0) {
          hint.textContent = `Available: ${configuredProviders.join(', ')} (configured in .env)`;
          // Auto-select first available AI provider
          const saved = localStorage.getItem('cnmn_ai_provider');
          if (saved && (saved === 'rules' || availableProviders[saved])) {
            selectProvider(saved);
          } else {
            selectProvider(configuredProviders[0].toLowerCase());
          }
        } else {
          hint.textContent = 'No AI providers configured. Using rule-based mode.';
          selectProvider('rules');
        }
      } catch (error) {
        hint.textContent = 'Server not running. Using rule-based mode only.';
        console.error('Failed to load providers:', error);
        // Hide AI options when server not available
        document.querySelector('[data-provider="openai"]').classList.add('unavailable');
        document.querySelector('[data-provider="anthropic"]').classList.add('unavailable');
        selectProvider('rules');
      }
    }

    function selectProvider(provider) {
      currentProvider = provider;
      document.querySelectorAll('.provider-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      const selected = document.querySelector(`[data-provider="${provider}"]`);
      if (selected) {
        selected.classList.add('selected');
      }
      localStorage.setItem('cnmn_ai_provider', provider);
    }

    function setStep(stepNum) {
      ['step1', 'step2', 'step3'].forEach((id, i) => {
        const el = document.getElementById(id);
        el.classList.remove('active', 'completed');
        if (i + 1 < stepNum) el.classList.add('completed');
        if (i + 1 === stepNum) el.classList.add('active');
      });
    }

    function renderChainWords(containerId, editable = false) {
      const container = document.getElementById(containerId);
      container.innerHTML = currentChain.map((word, i) =>
        `<span class="chain-word ${editable ? 'editable' : ''}" ${editable ? `onclick="editWord(${i})"` : ''}>${word}</span>`
      ).join('<span style="color:#8b6340">‚Üí</span>');
    }

    function editWord(index) {
      const newWord = prompt(`Edit word #${index + 1}:`, currentChain[index]);
      if (newWord && newWord.trim()) {
        currentChain[index] = newWord.trim().toUpperCase();
        renderChainWords('chainWords', true);
      }
    }

    // Step 1: Brainstorm Chain
    async function brainstormChain() {
      const input = document.getElementById('brainstormInput').value.trim();
      if (!input) {
        alert('Please enter a theme or starting word');
        return;
      }

      const resultBox = document.getElementById('brainstormResult');
      const chainPreview = document.getElementById('chainPreview');

      resultBox.classList.add('show');
      resultBox.innerHTML = '<div class="loading"><div class="spinner"></div>Generating chain ideas...</div>';
      chainPreview.classList.add('hidden');

      try {
        let result;
        if (currentProvider === 'rules') {
          result = ruleBasedBrainstorm(input);
        } else {
          result = await aiBrainstorm(input);
        }
        resultBox.textContent = result;

        // Extract chain words from result
        currentChain = extractChainFromResult(result);
        if (currentChain.length >= 4) {
          renderChainWords('chainWords', true);
          chainPreview.classList.remove('hidden');
        }
      } catch (error) {
        resultBox.textContent = `Error: ${error.message}`;
      }
    }

    function extractChainFromResult(text) {
      // Try to find numbered list (1. WORD, 2. WORD, etc.)
      const numberedMatch = text.match(/\d\.\s*([A-Z]+)/gi);
      if (numberedMatch && numberedMatch.length >= 4) {
        return numberedMatch.map(m => m.replace(/\d\.\s*/i, '').toUpperCase()).slice(0, 6);
      }

      // Try to find arrow-separated chain
      const arrowMatch = text.match(/([A-Z]{3,})\s*[‚Üí\-\>]+/gi);
      if (arrowMatch && arrowMatch.length >= 4) {
        return arrowMatch.map(m => m.replace(/\s*[‚Üí\-\>]+/gi, '').toUpperCase()).slice(0, 6);
      }

      // Try to find capitalized words in sequence
      const capsMatch = text.match(/\b[A-Z]{3,}\b/g);
      if (capsMatch && capsMatch.length >= 4) {
        return [...new Set(capsMatch)].slice(0, 6);
      }

      return [];
    }

    // Step 2: Create Disguises
    async function proceedToDisguises() {
      if (currentChain.length < 4) {
        alert('Need at least 4 words in the chain');
        return;
      }

      setStep(2);
      document.getElementById('brainstorm-section').classList.add('hidden');
      document.getElementById('disguise-section').classList.remove('hidden');

      renderChainWords('chainWordsSmall', false);

      const resultBox = document.getElementById('disguiseResult');
      resultBox.innerHTML = '<div class="loading"><div class="spinner"></div>Creating disguises...</div>';

      try {
        if (currentProvider === 'rules') {
          currentDisguises = ruleBasedDisguiseStructured(currentChain);
        } else {
          const result = await aiDisguise(currentChain.join('\n'));
          currentDisguises = parseAiDisguises(result);
        }
        renderDisguises();
        document.getElementById('disguiseActions').classList.remove('hidden');
      } catch (error) {
        resultBox.innerHTML = `<div style="color:red">Error: ${error.message}</div>`;
      }
    }

    function ruleBasedDisguiseStructured(words) {
      const result = {};
      words.forEach(word => {
        result[word] = createPhoneticVariants(word);
      });
      return result;
    }

    function parseAiDisguises(text) {
      const result = {};
      currentChain.forEach(word => {
        const regex = new RegExp(word + '[:\\s]+([a-z,\\s]+)', 'i');
        const match = text.match(regex);
        if (match) {
          result[word] = match[1].split(/[,\s]+/).filter(v => v.length >= 2).slice(0, 4);
        } else {
          result[word] = createPhoneticVariants(word);
        }
      });
      return result;
    }

    function renderDisguises() {
      const container = document.getElementById('disguiseResult');
      container.innerHTML = currentChain.map(word => `
        <div class="disguise-item">
          <div class="word">${word}</div>
          <div class="variants">
            ${(currentDisguises[word] || []).map((v, i) =>
              `<span class="variant ${i === 0 ? 'selected' : ''}" onclick="selectVariant(this, '${word}')">${v}</span>`
            ).join('')}
          </div>
        </div>
      `).join('');
    }

    function selectVariant(el, word) {
      el.parentElement.querySelectorAll('.variant').forEach(v => v.classList.remove('selected'));
      el.classList.add('selected');
    }

    async function regenerateDisguises() {
      const resultBox = document.getElementById('disguiseResult');
      resultBox.innerHTML = '<div class="loading"><div class="spinner"></div>Regenerating disguises...</div>';

      try {
        if (currentProvider === 'rules') {
          currentDisguises = ruleBasedDisguiseStructured(currentChain);
        } else {
          const result = await aiDisguise(currentChain.join('\n'));
          currentDisguises = parseAiDisguises(result);
        }
        renderDisguises();
      } catch (error) {
        resultBox.innerHTML = `<div style="color:red">Error: ${error.message}</div>`;
      }
    }

    // Step 3: Validation
    async function proceedToValidation() {
      setStep(3);
      document.getElementById('disguise-section').classList.add('hidden');
      document.getElementById('validate-section').classList.remove('hidden');

      renderChainWords('chainWordsFinal', false);

      const resultBox = document.getElementById('validateResult');
      resultBox.innerHTML = '<div class="loading"><div class="spinner"></div>Validating chain...</div>';

      try {
        let result;
        if (currentProvider === 'rules') {
          result = ruleBasedValidate(currentChain.join('\n'));
        } else {
          result = await aiValidate(currentChain.join('\n'));
        }

        const isSuccess = !result.includes('ERROR') && !result.includes('‚ö†Ô∏è');
        resultBox.className = `validation-result ${isSuccess ? 'success' : 'warning'}`;
        resultBox.innerHTML = `<pre style="white-space:pre-wrap;margin:0;font-family:inherit;">${result}</pre>`;
        document.getElementById('finalActions').classList.remove('hidden');
      } catch (error) {
        resultBox.innerHTML = `<div style="color:red">Error: ${error.message}</div>`;
      }
    }

    function copyForGenerator() {
      const selectedDisguises = {};
      currentChain.forEach(word => {
        const selected = document.querySelector(`.disguise-item .word:contains('${word}')`);
        const variant = document.querySelector(`.disguise-item:has(.word:contains('${word}')) .variant.selected`);
        selectedDisguises[word] = variant ? variant.textContent : (currentDisguises[word] || [''])[0];
      });

      // Fallback: get selected variants differently
      const items = document.querySelectorAll('.disguise-item');
      const output = currentChain.map((word, i) => {
        const item = [...items].find(el => el.querySelector('.word').textContent === word);
        const variant = item ? item.querySelector('.variant.selected')?.textContent : currentDisguises[word]?.[0];
        return `${i + 1}. ${word} ‚Üí ${variant || '?'}`;
      }).join('\n');

      const fullOutput = `Chain: ${currentChain.join(' ‚Üí ')}\n\nDisguises:\n${output}`;

      navigator.clipboard.writeText(fullOutput).then(() => {
        alert('Copied to clipboard!');
      }).catch(() => {
        prompt('Copy this:', fullOutput);
      });
    }

    function startOver() {
      currentChain = [];
      currentDisguises = {};
      setStep(1);
      document.getElementById('brainstorm-section').classList.remove('hidden');
      document.getElementById('disguise-section').classList.add('hidden');
      document.getElementById('validate-section').classList.add('hidden');
      document.getElementById('chainPreview').classList.add('hidden');
      document.getElementById('brainstormResult').classList.remove('show');
      document.getElementById('brainstormInput').value = '';
    }

    // Rule-based implementations
    function ruleBasedBrainstorm(input) {
      const strict = document.getElementById('strictConsistency').checked;

      // Strict mode: all items in same category
      const strictThemes = {
        'ocean': ['WHALE', 'SHARK', 'DOLPHIN', 'OCTOPUS', 'JELLYFISH', 'SEAHORSE'],
        'sports': ['TENNIS', 'SOCCER', 'BASEBALL', 'HOCKEY', 'GOLF', 'RUGBY'],
        'kitchen': ['KNIFE', 'WHISK', 'SPATULA', 'GRATER', 'PEELER', 'TONGS'],
        'music': ['PIANO', 'GUITAR', 'VIOLIN', 'DRUMS', 'TRUMPET', 'FLUTE'],
        'tools': ['HAMMER', 'WRENCH', 'SCREWDRIVER', 'PLIERS', 'SAW', 'DRILL'],
      };

      // Open mode: chains flow between categories
      const openThemes = {
        'ocean': ['WHALE', 'WAVE', 'ANCHOR', 'SHIP', 'PORT', 'HARBOR'],
        'sports': ['BALL', 'GOAL', 'POST', 'FLAG', 'POLE', 'VAULT'],
        'kitchen': ['KNIFE', 'CUT', 'STEAK', 'CATTLE', 'RANCH', 'HOUSE'],
        'music': ['PIANO', 'KEYS', 'LOCK', 'SAFE', 'VAULT', 'JUMP'],
        'tools': ['HAMMER', 'NAIL', 'FINGER', 'POINT', 'SCORE', 'MUSIC'],
      };

      const themes = strict ? strictThemes : openThemes;
      const lowerInput = input.toLowerCase();

      for (const [theme, chain] of Object.entries(themes)) {
        if (lowerInput.includes(theme) || chain.some(w => w.toLowerCase() === lowerInput)) {
          const modeNote = strict
            ? 'üîí STRICT MODE: All words are within the same category.'
            : 'üîì OPEN MODE: Chain flows between related categories.';
          return `üí° CHAIN SUGGESTION for "${input}":\n\n${chain.map((w, i) => `${i + 1}. ${w}`).join('\n')}\n\n${modeNote}\n\nüîó CONNECTIONS:\n1‚Üí2: Similar characteristics\n2‚Üí3: Related function\n3‚Üí4: Material or location\n4‚Üí5: Homophone or related concept\n5‚Üí6: Final connection`;
        }
      }

      const modeHint = strict
        ? `All 6 words should be examples of "${input}" (same category).`
        : `Chain can flow from "${input}" to related concepts.`;

      return `üí° CHAIN BUILDING TIPS for "${input}":\n\n${modeHint}\n\n1. ${input.toUpperCase()}\n2. (next word)\n3. (next word)\n4. (next word)\n5. (next word)\n6. (final word)\n\nUse an AI provider for better suggestions!`;
    }

    function createPhoneticVariants(word) {
      const variants = [];
      const lower = word.toLowerCase();

      let variant1 = lower.replace(/[aeiou]/gi, '');
      if (variant1.length < 3) variant1 = lower.replace(/[aeiou](?!$)/gi, '');
      variants.push(variant1);

      let variant2 = lower.replace(/[aou]/gi, '');
      variants.push(variant2);

      let variant3 = lower.replace(/(.)\1+/g, '$1').replace(/[aeiou]/gi, '');
      variants.push(variant3);

      let variant4 = lower.slice(0, 4).replace(/[aeiou]/gi, '');
      if (variant4.length >= 2) variants.push(variant4);

      return [...new Set(variants)].filter(v => v.length >= 2).slice(0, 4);
    }

    function ruleBasedValidate(input) {
      const words = input.split('\n').filter(w => w.trim()).map(w => w.trim().toUpperCase());

      if (words.length !== 6) {
        return `‚ö†Ô∏è VALIDATION WARNING:\nExpected 6 words, found ${words.length}.\n\nA puzzle chain typically has 6 links.`;
      }

      let result = `‚úÖ CHAIN VALIDATION:\n${words.join(' ‚Üí ')}\n\n`;
      result += 'üìä ANALYSIS:\n';
      result += `‚úì Length: ${words.length} words\n`;
      result += `‚úì Word lengths: ${words.map(w => w.length).join(', ')}\n`;
      result += `‚úì Unique words: ${new Set(words).size === words.length ? 'Yes' : 'No (duplicates!)'}\n\n`;

      result += 'üí≠ CONNECTIONS TO DEFINE:\n';
      words.forEach((word, i) => {
        if (i < words.length - 1) {
          result += `${i + 1}. ${word} ‚Üí ${words[i + 1]}: ?\n`;
        }
      });

      return result;
    }

    // AI-based implementations
    async function aiBrainstorm(input) {
      const strict = document.getElementById('strictConsistency').checked;
      let prompt;

      if (strict) {
        prompt = `You are helping create a word chain puzzle. Generate a 6-word chain where ALL words belong to the category "${input}". Every word must be a specific example within this category - do not drift to related categories.

For example, if the category is "kitchen tools", all 6 words should be kitchen tools (knife, whisk, spatula, etc.), NOT foods or cooking actions.

Format as a numbered list:
1. WORD
2. WORD
...

Then briefly explain the connection between each adjacent pair (they should share properties, uses, or characteristics while staying in the same category).`;
      } else {
        prompt = `You are helping create a word chain puzzle. Generate a 6-word chain starting with or related to "${input}". Each word should connect to the next with a clear logical relationship - the chain can flow naturally between related categories.

For example, "kitchen tools" might lead to: KNIFE ‚Üí CUT ‚Üí STEAK ‚Üí CATTLE ‚Üí RANCH ‚Üí HOUSE

Format as a numbered list:
1. WORD
2. WORD
...

Then briefly explain each connection.`;
      }
      return await callServer(prompt);
    }

    async function aiDisguise(input) {
      const prompt = `Create phonetic disguises for these words by removing vowels and simplifying spelling while keeping them pronounceable:\n\n${input}\n\nFor each word, provide 3-4 variants. Format: WORD: var1, var2, var3`;
      return await callServer(prompt);
    }

    async function aiValidate(input) {
      const prompt = `Validate this word puzzle chain. Check if:\n1. Each connection is logical and discoverable\n2. Difficulty is appropriate\n3. Words work well for phonetic disguises\n\nChain:\n${input}\n\nProvide specific feedback on each connection.`;
      return await callServer(prompt);
    }

    async function callServer(prompt) {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ provider: currentProvider, prompt })
      });

      const data = await response.json();
      if (!response.ok || data.error) {
        throw new Error(data.error || `Server error: ${response.statusText}`);
      }
      return data.content;
    }

    // Initialize
    loadProviders();
  </script>
</body>
</html>
