<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cnmn Quiz Generator</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(165deg, #fdfbf7 0%, #f5e6d3 50%, #ecdbc8 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    h1 {
      color: #6b3410;
      margin-bottom: 10px;
      font-size: 28px;
      letter-spacing: 2px;
    }

    .subtitle {
      color: #8b6340;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 4px 20px rgba(107, 52, 16, 0.1);
      margin-bottom: 20px;
    }

    .panel h2 {
      color: #6b3410;
      margin-bottom: 16px;
      font-size: 18px;
    }

    .form-row {
      display: flex;
      gap: 12px;
      align-items: end;
      margin-bottom: 16px;
    }

    .form-group {
      flex: 1;
    }

    label {
      display: block;
      margin-bottom: 6px;
      color: #6b3410;
      font-weight: 600;
      font-size: 13px;
    }

    input[type="text"], select {
      width: 100%;
      padding: 10px 12px;
      border: 2px solid #c4a574;
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #6b3410;
    }

    button {
      background: #6b3410;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    button:hover {
      background: #8b4513;
    }

    button:disabled {
      background: #c4a574;
      cursor: not-allowed;
    }

    button.small {
      padding: 6px 10px;
      font-size: 12px;
    }

    button.secondary {
      background: #8b6340;
    }

    button.export {
      background: #2e7d32;
    }

    button.export:hover {
      background: #388e3c;
    }

    .hint {
      font-size: 12px;
      color: #8b6340;
      margin-top: 4px;
      font-style: italic;
    }


    /* Model selector */
    .model-bar {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 16px;
      border-bottom: 2px solid #ecdbc8;
    }

    .model-bar label {
      margin: 0;
      white-space: nowrap;
    }

    .model-select {
      flex: 1;
      max-width: 300px;
      padding: 8px 12px;
      border: 2px solid #c4a574;
      border-radius: 6px;
      font-size: 13px;
      font-family: inherit;
      background: white;
      color: #6b3410;
      cursor: pointer;
      transition: border-color 0.2s;
    }

    .model-select:focus {
      outline: none;
      border-color: #6b3410;
    }

    .model-status {
      font-size: 12px;
      color: #8b6340;
      margin-left: auto;
      white-space: nowrap;
    }

    /* Question cards */
    .questions-grid {
      display: grid;
      gap: 16px;
    }

    .question-card {
      background: white;
      border: 2px solid #ecdbc8;
      border-radius: 12px;
      padding: 16px;
    }

    .question-card h3 {
      color: #6b3410;
      font-size: 14px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .question-card h3 .num {
      background: #6b3410;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .field-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    .field-row label {
      width: 70px;
      margin: 0;
      font-size: 12px;
    }

    .field-row input {
      flex: 1;
      padding: 6px 10px;
      font-size: 13px;
    }

    .disguise-preview {
      font-family: 'Courier New', monospace;
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      min-width: 60px;
      text-align: center;
    }

    .disguise-input {
      font-family: 'Courier New', monospace;
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      width: 70px;
      text-align: center;
      border: 2px solid #2d2d2d;
    }

    .disguise-input:focus {
      border-color: #6b3410;
      outline: none;
    }

    .type-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      background: #ecdbc8;
      color: #6b3410;
      white-space: nowrap;
    }

    .type-badge.wrong-letters { background: #ffcdd2; color: #c62828; }
    .type-badge.non-synonym { background: #fff3e0; color: #e65100; }
    .type-badge.phonetic-trap { background: #e3f2fd; color: #1565c0; }

    .type-badge.clickable {
      cursor: pointer;
    }
    .type-badge.clickable:hover {
      opacity: 0.8;
    }

    .distractors-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #ecdbc8;
    }

    .distractors-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .distractors-header label {
      font-size: 12px;
      margin: 0;
    }

    /* Loading state */
    .loading {
      text-align: center;
      padding: 40px;
      color: #8b6340;
    }

    .spinner {
      border: 3px solid #ecdbc8;
      border-top: 3px solid #6b3410;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #themeInput.ideating::placeholder {
      font-style: italic;
    }

    .icon-retry-spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #ecdbc8;
      border-top: 2px solid #6b3410;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: inline-block;
    }

    .emoji-btn.retrying {
      opacity: 0.5;
      pointer-events: none;
    }

    .icon-retry-log-btn {
      font-size: 10px;
      padding: 1px 5px;
      border-radius: 8px;
      background: #ecdbc8;
      color: #6b3410;
      border: 1px solid #c4a574;
      cursor: pointer;
      margin-left: 4px;
      white-space: nowrap;
    }

    .icon-retry-log {
      font-size: 11px;
      background: #fdf6ec;
      border: 1px solid #ecdbc8;
      border-radius: 6px;
      padding: 6px 10px;
      margin-top: 4px;
      color: #5a3a1a;
      line-height: 1.5;
    }

    .icon-retry-log .log-entry { margin: 2px 0; }
    .icon-retry-log .log-ok { color: #2a7d2a; }
    .icon-retry-log .log-fail { color: #a04030; }
    .icon-retry-log .log-skip { color: #8b6340; }

    /* Hidden */
    .hidden {
      display: none !important;
    }

    /* Export section */
    .export-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid #ecdbc8;
      display: flex;
      gap: 12px;
    }

    /* Empty state */
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #8b6340;
    }

    .empty-state h3 {
      color: #6b3410;
      margin-bottom: 8px;
    }

    /* Emoji picker */
    .emoji-picker-container {
      position: relative;
      display: inline-block;
    }

    .emoji-btn {
      width: 40px;
      height: 36px;
      font-size: 20px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 2px solid #c4a574;
      color: #6b3410;
    }

    .emoji-btn:hover {
      background: #f5e6d3;
    }

    .emoji-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      z-index: 100;
      background: white;
      border: 2px solid #c4a574;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      width: 340px;
      flex-direction: column;
    }

    .emoji-dropdown.open {
      display: flex;
    }

    .emoji-search {
      padding: 10px;
      border-bottom: 1px solid #ecdbc8;
    }

    .emoji-search input {
      width: 100%;
      padding: 8px 12px;
      border: 2px solid #ecdbc8;
      border-radius: 6px;
      font-size: 13px;
      outline: none;
    }

    .emoji-search input:focus {
      border-color: #c4a574;
    }

    .emoji-tabs {
      display: flex;
      border-bottom: 1px solid #ecdbc8;
      padding: 0 6px;
      overflow-x: auto;
      scrollbar-width: none;
    }

    .emoji-tabs::-webkit-scrollbar {
      display: none;
    }

    .emoji-tab {
      padding: 8px 6px;
      font-size: 18px;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      opacity: 0.5;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .emoji-tab:hover {
      opacity: 0.8;
    }

    .emoji-tab.active {
      opacity: 1;
      border-bottom-color: #6b3410;
    }

    .emoji-grid-container {
      height: 200px;
      overflow-y: auto;
      padding: 8px;
    }

    .emoji-section-label {
      font-size: 11px;
      color: #8b6340;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 4px 4px 8px;
      font-weight: 600;
    }

    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
    }

    .emoji-option {
      width: 34px;
      height: 34px;
      font-size: 22px;
      background: none;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.15s;
    }

    .emoji-option:hover {
      background: #f5e6d3;
      transform: scale(1.15);
    }

    .emoji-footer {
      display: flex;
      justify-content: space-between;
      padding: 8px 10px;
      border-top: 1px solid #ecdbc8;
      background: #faf7f2;
      border-radius: 0 0 10px 10px;
    }

    .emoji-clear {
      background: #ecdbc8;
      color: #6b3410;
      font-size: 11px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }

    .emoji-clear:hover {
      background: #dcc9a8;
    }

    .emoji-no-results {
      text-align: center;
      padding: 30px;
      color: #8b6340;
      font-size: 13px;
    }

    .emoji-direct-input {
      width: 90px;
      padding: 5px 8px;
      border: 2px solid #ecdbc8;
      border-radius: 4px;
      font-size: 16px;
      text-align: center;
    }

    .emoji-direct-input:focus {
      border-color: #c4a574;
      outline: none;
    }

    .emoji-ai-suggest {
      background: #6b3410;
      color: white;
      font-size: 11px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }

    .emoji-ai-suggest:hover:not(:disabled) {
      background: #8b4513;
    }

    .emoji-ai-suggest:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .emoji-option.suggested {
      box-shadow: 0 0 0 2px #c4a574;
      border-radius: 6px;
    }

    /* Image picker (Unsplash) */
    .image-picker-toggle {
      display: flex;
      gap: 0;
      margin-bottom: 4px;
    }

    .image-picker-toggle button {
      flex: 1;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 600;
      border: 2px solid #c4a574;
      background: #faf7f2;
      color: #8b6340;
      cursor: pointer;
      transition: all 0.15s;
    }

    .image-picker-toggle button:first-child {
      border-radius: 6px 0 0 6px;
    }

    .image-picker-toggle button:last-child {
      border-radius: 0 6px 6px 0;
    }

    .image-picker-toggle button.active {
      background: #6b3410;
      color: white;
      border-color: #6b3410;
    }

    .image-picker-toggle button:hover:not(.active) {
      background: #f0e4d3;
    }

    .icon-search-row {
      display: flex;
      gap: 6px;
      padding: 10px;
      border-bottom: 1px solid #ecdbc8;
    }

    .icon-search-row input {
      flex: 1;
      padding: 8px 12px;
      border: 2px solid #ecdbc8;
      border-radius: 6px;
      font-size: 13px;
      outline: none;
    }

    .icon-search-row input:focus {
      border-color: #c4a574;
    }

    .icon-search-row button {
      padding: 8px 14px;
      font-size: 12px;
    }

    .icon-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      padding: 8px;
      height: 240px;
      overflow-y: auto;
    }

    .icon-thumb {
      cursor: pointer;
      border-radius: 6px;
      aspect-ratio: 1;
      border: 2px solid transparent;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      background: #faf7f2;
    }

    .icon-thumb:hover {
      border-color: #6b3410;
      transform: scale(1.08);
      background: #f0e6d6;
    }

    .icon-thumb img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .icon-empty {
      text-align: center;
      padding: 40px 20px;
      color: #8b6340;
      font-size: 13px;
      grid-column: 1 / -1;
    }

    .icon-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border-top: 1px solid #ecdbc8;
      background: #faf7f2;
      border-radius: 0 0 10px 10px;
    }

    .icon-footer span {
      font-size: 10px;
      color: #8b6340;
    }

    .image-preview {
      width: 40px;
      height: 36px;
      border-radius: 4px;
      overflow: hidden;
      border: 2px solid #c4a574;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      cursor: pointer;
    }

    .image-preview img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    /* Difficulty badges */
    .difficulty-badge {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .difficulty-badge.easy { background: #e8f5e9; color: #2e7d32; }
    .difficulty-badge.medium { background: #fff3e0; color: #e65100; }
    .difficulty-badge.hard { background: #ffebee; color: #c62828; }
  </style>
</head>
<body>
  <div class="container">
    <h1>cnmn Quiz Generator</h1>
    <p class="subtitle">Generate themed synonym puzzles with phonetic disguises</p>

    <!-- Model Selection -->
    <div class="panel">
      <div class="model-bar">
        <label>Model:</label>
        <select class="model-select" id="modelSelect" onchange="selectModel()">
          <option value="">Loading...</option>
        </select>
        <span class="model-status" id="modelStatus">Checking...</span>
      </div>

      <div class="form-row">
        <div class="form-group">
          <label>Theme</label>
          <input type="text" id="themeInput" placeholder="" autofocus onkeydown="if(event.key==='Enter')generateQuiz()">
        </div>
        <div class="form-group" style="max-width: 180px;">
          <label>Publication Date</label>
          <input type="date" id="pubDate">
        </div>
        <button onclick="generateQuiz()" id="generateBtn">Generate 6 Questions</button>
      </div>
      <p class="hint">Enter a theme and publication date to generate 6 synonym quiz questions with increasing difficulty.</p>
      <div id="puzzleList" style="font-size: 0.85em; color: #666; margin-top: 8px; line-height: 1.6; display: flex; flex-wrap: wrap; column-gap: 16px;"></div>
    </div>

    <!-- Questions -->
    <div class="panel" id="questionsPanel">
      <h2>Quiz Questions</h2>

      <div id="questionsContainer">
        <div class="empty-state">
          <h3>No quiz generated yet</h3>
          <p>Enter a theme above and click "Generate 6 Questions"</p>
        </div>
      </div>

      <div class="export-section hidden" id="exportSection">
        <button class="export" onclick="saveQuiz()">üíæ Save Puzzle</button>
        <button class="secondary" onclick="exportQuiz()">üìã Copy JSON</button>
        <button class="secondary" onclick="clearQuiz()">üóëÔ∏è Clear</button>
      </div>
    </div>
  </div>

  <script>
    // State
    let currentModel = '';
    let previousThemes = [];
    let quiz = {
      theme: '',
      publicationDate: '',
      questions: []  // Array of 6 question objects
    };

    // Initialize date picker to next missing date starting from tomorrow
    function localDateStr(d) {
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

    async function initPubDate() {
      try {
        const resp = await fetch('/api/puzzle-dates');
        if (resp.ok) {
          const puzzles = await resp.json();
          const dateSet = new Set(puzzles.map(p => p.date));
          const candidate = new Date();
          candidate.setDate(candidate.getDate() + 1);
          // Walk forward from tomorrow until we find a date with no puzzle
          while (dateSet.has(localDateStr(candidate))) {
            candidate.setDate(candidate.getDate() + 1);
          }
          document.getElementById('pubDate').value = localDateStr(candidate);
          renderPuzzleList(puzzles);
          previousThemes = puzzles.map(p => p.theme).filter(Boolean).slice(-100);
          return;
        }
      } catch {}
      // Fallback: tomorrow
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      document.getElementById('pubDate').value = localDateStr(tomorrow);
    }

    function renderPuzzleList(puzzles) {
      const el = document.getElementById('puzzleList');
      if (!puzzles.length) { el.innerHTML = ''; return; }
      const items = puzzles.map(p => {
        const short = p.date.slice(5);
        return `<span style="white-space:nowrap">${short} <strong>${p.theme || '(no theme)'}</strong></span>`;
      }).join('');
      el.innerHTML = items;
    }

    async function suggestThemes() {
      const input = document.getElementById('themeInput');
      if (!previousThemes.length || currentModel === 'rules' || !currentModel) {
        input.placeholder = 'e.g., Buildings, Emotions, Weather, Animals';
        return;
      }
      input.classList.add('ideating');
      let dots = 0;
      const dotTimer = setInterval(() => {
        dots = (dots + 1) % 4;
        input.placeholder = 'ideating on new themes' + '.'.repeat(dots);
      }, 400);
      try {
        const themeList = previousThemes.join(', ');
        const result = await callServer(
          `Here are themes already used for a daily word puzzle game: ${themeList}\n\nSuggest 4 fresh, diverse theme ideas that haven't been used yet. Reply with ONLY the 4 themes separated by commas, nothing else.`,
          { maxTokens: 60 }
        );
        const suggestions = result.trim();
        if (suggestions) {
          input.placeholder = `e.g., ${suggestions}`;
        }
      } catch {
        input.placeholder = 'e.g., Buildings, Emotions, Weather, Animals';
      }
      clearInterval(dotTimer);
      input.classList.remove('ideating');
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await Promise.all([initPubDate(), loadModels()]);
      suggestThemes();
    });

    // Question structure:
    // {
    //   prompt: "shed",
    //   emoji: "üè†",
    //   rejectedPrompts: [],
    //   answer: { word: "GARAGE", disguise: "grj" },
    //   rejectedAnswers: [],
    //   distractors: [
    //     { word: "LEAN-TO", disguise: "lntso", type: "wrong-letters" },
    //     { word: "PORCH", disguise: "prch", type: "non-synonym" },
    //     { word: "SHACK", disguise: "chk", type: "phonetic-trap" }
    //   ],
    //   rejectedDistractors: []
    // }

    // Comprehensive emoji data organized by category
    const emojiCategories = {
      'Smileys': {
        icon: 'üòÄ',
        emojis: ['üòÄ','üòÉ','üòÑ','üòÅ','üòÖ','üòÇ','ü§£','üòä','üòá','üôÇ','üòâ','üòå','üòç','ü•∞','üòò','üòã','üòõ','üòú','ü§™','üòù','ü§ë','ü§ó','ü§≠','ü§´','ü§î','ü§ê','ü§®','üòê','üòë','üò∂','üòè','üòí','üôÑ','üò¨','üòÆ‚Äçüí®','ü§•','üòå','üòî','üò™','ü§§','üò¥','üò∑','ü§í','ü§ï','ü§¢','ü§Æ','ü§ß','ü•µ','ü•∂','ü•¥','üòµ','ü§Ø','ü§†','ü•≥','ü•∏','üòé','ü§ì','üßê','üòï','üòü','üôÅ','‚òπÔ∏è','üòÆ','üòØ','üò≤','üò≥','ü•∫','üò¶','üòß','üò®','üò∞','üò•','üò¢','üò≠','üò±','üòñ','üò£','üòû','üòì','üò©','üò´','ü•±','üò§','üò°','üò†','ü§¨','üòà','üëø','üíÄ','‚ò†Ô∏è','üí©','ü§°','üëπ','üë∫','üëª','üëΩ','üëæ','ü§ñ']
      },
      'People': {
        icon: 'üëã',
        emojis: ['üëã','ü§ö','üñêÔ∏è','‚úã','üññ','üëå','ü§å','ü§è','‚úåÔ∏è','ü§û','ü§ü','ü§ò','ü§ô','üëà','üëâ','üëÜ','üñï','üëá','‚òùÔ∏è','üëç','üëé','‚úä','üëä','ü§õ','ü§ú','üëè','üôå','üëê','ü§≤','ü§ù','üôè','‚úçÔ∏è','üíÖ','ü§≥','üí™','ü¶æ','ü¶ø','ü¶µ','ü¶∂','üëÇ','ü¶ª','üëÉ','üß†','ü´Ä','ü´Å','ü¶∑','ü¶¥','üëÄ','üëÅÔ∏è','üëÖ','üëÑ','üë∂','üßí','üë¶','üëß','üßë','üë±','üë®','üßî','üë©','üßì','üë¥','üëµ','üôç','üôé','üôÖ','üôÜ','üíÅ','üôã','üßè','üôá','ü§¶','ü§∑','üëÆ','üïµÔ∏è','üíÇ','ü•∑','üë∑','ü§¥','üë∏','üë≥','üë≤','üßï','ü§µ','üë∞','ü§∞','ü´É','ü´Ñ','ü§±','üëº','üéÖ','ü§∂','ü¶∏','ü¶π','üßô','üßö','üßõ','üßú','üßù','üßû','üßü','üíÜ','üíá','üö∂','üßç','üßé','üèÉ','üíÉ','üï∫','üï¥Ô∏è','üëØ','üßñ','üßó','ü§∏','üèåÔ∏è','üèá','‚õ∑Ô∏è','üèÇ','üèãÔ∏è','ü§º','ü§Ω','ü§æ','ü§∫','‚õπÔ∏è','üèä','üö£','üßò','üõÄ','üõå']
      },
      'Animals': {
        icon: 'üêæ',
        emojis: ['üê∂','üêï','ü¶Æ','üêï‚Äçü¶∫','üê©','üê∫','ü¶ä','ü¶ù','üê±','üêà','üêà‚Äç‚¨õ','ü¶Å','üêØ','üêÖ','üêÜ','üê¥','üêé','ü¶Ñ','ü¶ì','ü¶å','ü¶¨','üêÆ','üêÇ','üêÉ','üêÑ','üê∑','üêñ','üêó','üêΩ','üêè','üêë','üêê','üê™','üê´','ü¶ô','ü¶í','üêò','ü¶£','ü¶è','ü¶õ','üê≠','üêÅ','üêÄ','üêπ','üê∞','üêá','üêøÔ∏è','ü¶´','ü¶î','ü¶á','üêª','üêª‚Äç‚ùÑÔ∏è','üê®','üêº','ü¶•','ü¶¶','ü¶®','ü¶ò','ü¶°','üêæ','ü¶É','üêî','üêì','üê£','üê§','üê•','üê¶','üêß','üïäÔ∏è','ü¶Ö','ü¶Ü','ü¶¢','ü¶â','ü¶§','ü™∂','ü¶©','ü¶ö','ü¶ú','üê∏','üêä','üê¢','ü¶é','üêç','üê≤','üêâ','ü¶ï','ü¶ñ','üê≥','üêã','üê¨','ü¶≠','üêü','üê†','üê°','ü¶à','üêô','üêö','üêå','ü¶ã','üêõ','üêú','üêù','ü™≤','üêû','ü¶ó','ü™≥','üï∑Ô∏è','üï∏Ô∏è','ü¶Ç','ü¶ü','ü™∞','ü™±','ü¶†']
      },
      'Nature': {
        icon: 'üåø',
        emojis: ['üíê','üå∏','üíÆ','üèµÔ∏è','üåπ','ü•Ä','üå∫','üåª','üåº','üå∑','üå±','ü™¥','üå≤','üå≥','üå¥','üåµ','üåæ','üåø','‚òòÔ∏è','üçÄ','üçÅ','üçÇ','üçÉ','üçá','üçà','üçâ','üçä','üçã','üçå','üçç','ü•≠','üçé','üçè','üçê','üçë','üçí','üçì','ü´ê','ü•ù','üçÖ','ü´í','ü••','ü•ë','üçÜ','ü•î','ü•ï','üåΩ','üå∂Ô∏è','ü´ë','ü•í','ü•¨','ü•¶','üßÑ','üßÖ','üçÑ','ü•ú','üå∞','üçû','ü•ê','ü•ñ','ü´ì','ü•®','ü•Ø','ü•û','üßá','üßÄ','üçñ','üçó','ü•©','ü•ì','üçî','üçü','üçï','üå≠','ü•™','üåÆ','üåØ','ü´î','ü•ô','üßÜ','ü•ö','üç≥','ü•ò','üç≤','ü´ï','ü•£','ü•ó','üçø','üßà','üßÇ','ü•´','üç±','üçò','üçô','üçö','üçõ','üçú','üçù','üç†','üç¢','üç£','üç§','üç•','ü•Æ','üç°','ü•ü','ü•†','ü•°','ü¶Ä','ü¶û','ü¶ê','ü¶ë','ü¶™','üç¶','üçß','üç®','üç©','üç™','üéÇ','üç∞','üßÅ','ü•ß','üç´','üç¨','üç≠','üçÆ','üçØ','üçº','ü•õ','‚òï','ü´ñ','üçµ','üç∂','üçæ','üç∑','üç∏','üçπ','üç∫','üçª','ü•Ç','ü•É','ü•§','üßã','üßÉ','üßâ','üßä']
      },
      'Travel': {
        icon: '‚úàÔ∏è',
        emojis: ['üöó','üöï','üöô','üöå','üöé','üèéÔ∏è','üöì','üöë','üöí','üöê','üõª','üöö','üöõ','üöú','üèçÔ∏è','üõµ','üö≤','üõ¥','üõπ','üõº','üöè','üõ£Ô∏è','üõ§Ô∏è','üõ¢Ô∏è','‚õΩ','üö®','üö•','üö¶','üõë','üöß','‚öì','‚õµ','üõ∂','üö§','üõ≥Ô∏è','‚õ¥Ô∏è','üõ•Ô∏è','üö¢','‚úàÔ∏è','üõ©Ô∏è','üõ´','üõ¨','ü™Ç','üí∫','üöÅ','üöü','üö†','üö°','üõ∞Ô∏è','üöÄ','üõ∏','üõéÔ∏è','üß≥','‚åõ','‚è≥','‚åö','‚è∞','‚è±Ô∏è','‚è≤Ô∏è','üï∞Ô∏è','üå°Ô∏è','üó∫Ô∏è','üß≠','üèîÔ∏è','‚õ∞Ô∏è','üåã','üóª','üèïÔ∏è','üèñÔ∏è','üèúÔ∏è','üèùÔ∏è','üèûÔ∏è','üèüÔ∏è','üèõÔ∏è','üèóÔ∏è','üß±','ü™®','ü™µ','üõñ','üèòÔ∏è','üèöÔ∏è','üè†','üè°','üè¢','üè£','üè§','üè•','üè¶','üè®','üè©','üè™','üè´','üè¨','üè≠','üèØ','üè∞','üíí','üóº','üóΩ','‚õ™','üïå','üõï','üïç','‚õ©Ô∏è','üïã','‚õ≤','‚õ∫','üåÅ','üåÉ','üèôÔ∏è','üåÑ','üåÖ','üåÜ','üåá','üåâ','üé†','üé°','üé¢','üíà','üé™']
      },
      'Activities': {
        icon: '‚öΩ',
        emojis: ['‚öΩ','üèÄ','üèà','‚öæ','ü•é','üéæ','üèê','üèâ','ü•è','üé±','ü™Ä','üèì','üè∏','üèí','üèë','ü•ç','üèè','ü™É','ü•Ö','‚õ≥','ü™Å','üèπ','üé£','ü§ø','ü•ä','ü•ã','üéΩ','üõ∑','üéø','‚õ∑Ô∏è','üèÇ','ü™Ç','üèãÔ∏è','ü§º','ü§∏','ü§∫','‚õπÔ∏è','ü§æ','üèåÔ∏è','üèá','‚õ∏Ô∏è','üèä','üö¥','üöµ','üßó','ü§Ω','üéñÔ∏è','üèÜ','ü•á','ü•à','ü•â','üéÉ','üéÑ','üéÜ','üéá','üß®','‚ú®','üéà','üéâ','üéä','üéã','üéç','üéé','üéè','üéê','üéë','üßß','üéÄ','üéÅ','üéóÔ∏è','üéüÔ∏è','üé´','üé†','üé°','üé¢','üé™','üé≠','üñºÔ∏è','üé®','üßµ','ü™°','üß∂','ü™¢']
      },
      'Objects': {
        icon: 'üí°',
        emojis: ['‚åö','üì±','üì≤','üíª','‚å®Ô∏è','üñ•Ô∏è','üñ®Ô∏è','üñ±Ô∏è','üñ≤Ô∏è','üïπÔ∏è','üóúÔ∏è','üíΩ','üíæ','üíø','üìÄ','üìº','üì∑','üì∏','üìπ','üé•','üìΩÔ∏è','üéûÔ∏è','üìû','‚òéÔ∏è','üìü','üì†','üì∫','üìª','üéôÔ∏è','üéöÔ∏è','üéõÔ∏è','üß≠','‚è±Ô∏è','‚è≤Ô∏è','‚è∞','üï∞Ô∏è','‚åõ','‚è≥','üì°','üîã','üîå','üí°','üî¶','üïØÔ∏è','ü™î','üßØ','üõ¢Ô∏è','üí∏','üíµ','üí¥','üí∂','üí∑','ü™ô','üí∞','üí≥','üíé','‚öñÔ∏è','ü™ú','üß∞','ü™õ','üîß','üî®','‚öíÔ∏è','üõ†Ô∏è','‚õèÔ∏è','ü™ö','üî©','‚öôÔ∏è','ü™§','üß±','‚õìÔ∏è','üß≤','üî´','üí£','üß®','ü™ì','üî™','üó°Ô∏è','‚öîÔ∏è','üõ°Ô∏è','üö¨','‚ö∞Ô∏è','ü™¶','‚ö±Ô∏è','üè∫','üîÆ','üìø','üßø','üíà','‚öóÔ∏è','üî≠','üî¨','üï≥Ô∏è','ü©π','ü©∫','üíä','üíâ','ü©∏','üß¨','ü¶†','üß´','üß™','üå°Ô∏è','üßπ','ü™†','üß∫','üßª','üöΩ','üö∞','üöø','üõÅ','üõÄ','üßº','ü™•','ü™í','üßΩ','ü™£','üß¥','üõéÔ∏è','üîë','üóùÔ∏è','üö™','ü™ë','üõãÔ∏è','üõèÔ∏è','üõå','üß∏','ü™Ü','üñºÔ∏è','ü™û','ü™ü','üõí','üéÅ','üéà','üéè','üéÄ','ü™Ñ','ü™Ö','üéä','üéâ','üéé','üèÆ','üéê','üßß','‚úâÔ∏è','üì©','üì®','üìß','üíå','üì•','üì§','üì¶','üè∑Ô∏è','üì™','üì´','üì¨','üì≠','üìÆ','üìØ','üìú','üìÉ','üìÑ','üìë','üßæ','üìä','üìà','üìâ','üóíÔ∏è','üóìÔ∏è','üìÜ','üìÖ','üóëÔ∏è','üìá','üóÉÔ∏è','üó≥Ô∏è','üóÑÔ∏è','üìã','üìÅ','üìÇ','üóÇÔ∏è','üóûÔ∏è','üì∞','üìì','üìî','üìí','üìï','üìó','üìò','üìô','üìö','üìñ','üîñ','üß∑','üîó','üìé','üñáÔ∏è','üìê','üìè','üßÆ','üìå','üìç','‚úÇÔ∏è','üñäÔ∏è','üñãÔ∏è','‚úíÔ∏è','üñåÔ∏è','üñçÔ∏è','üìù','‚úèÔ∏è','üîç','üîé','üîè','üîê','üîí','üîì']
      },
      'Symbols': {
        icon: '‚ù§Ô∏è',
        emojis: ['‚ù§Ô∏è','üß°','üíõ','üíö','üíô','üíú','üñ§','ü§ç','ü§é','üíî','‚ù£Ô∏è','üíï','üíû','üíì','üíó','üíñ','üíò','üíù','üíü','‚òÆÔ∏è','‚úùÔ∏è','‚ò™Ô∏è','üïâÔ∏è','‚ò∏Ô∏è','‚ú°Ô∏è','üîØ','üïé','‚òØÔ∏è','‚ò¶Ô∏è','üõê','‚õé','‚ôà','‚ôâ','‚ôä','‚ôã','‚ôå','‚ôç','‚ôé','‚ôè','‚ôê','‚ôë','‚ôí','‚ôì','üÜî','‚öõÔ∏è','üâë','‚ò¢Ô∏è','‚ò£Ô∏è','üì¥','üì≥','üà∂','üàö','üà∏','üà∫','üà∑Ô∏è','‚ú¥Ô∏è','üÜö','üíÆ','üâê','„äôÔ∏è','„äóÔ∏è','üà¥','üàµ','üàπ','üà≤','üÖ∞Ô∏è','üÖ±Ô∏è','üÜé','üÜë','üÖæÔ∏è','üÜò','‚ùå','‚≠ï','üõë','‚õî','üìõ','üö´','üíØ','üí¢','‚ô®Ô∏è','üö∑','üöØ','üö≥','üö±','üîû','üìµ','üö≠','‚ùó','‚ùï','‚ùì','‚ùî','‚ÄºÔ∏è','‚ÅâÔ∏è','üîÖ','üîÜ','„ÄΩÔ∏è','‚ö†Ô∏è','üö∏','üî±','‚öúÔ∏è','üî∞','‚ôªÔ∏è','‚úÖ','üàØ','üíπ','‚ùáÔ∏è','‚ú≥Ô∏è','‚ùé','üåê','üí†','‚ìÇÔ∏è','üåÄ','üí§','üèß','üöæ','‚ôø','üÖøÔ∏è','üõó','üà≥','üàÇÔ∏è','üõÇ','üõÉ','üõÑ','üõÖ','üöπ','üö∫','üöº','‚ößÔ∏è','üöª','üöÆ','üé¶','üì∂','üàÅ','üî£','‚ÑπÔ∏è','üî§','üî°','üî†','üÜñ','üÜó','üÜô','üÜí','üÜï','üÜì','0Ô∏è‚É£','1Ô∏è‚É£','2Ô∏è‚É£','3Ô∏è‚É£','4Ô∏è‚É£','5Ô∏è‚É£','6Ô∏è‚É£','7Ô∏è‚É£','8Ô∏è‚É£','9Ô∏è‚É£','üîü','üî¢','#Ô∏è‚É£','*Ô∏è‚É£','‚èèÔ∏è','‚ñ∂Ô∏è','‚è∏Ô∏è','‚èØÔ∏è','‚èπÔ∏è','‚è∫Ô∏è','‚è≠Ô∏è','‚èÆÔ∏è','‚è©','‚è™','‚è´','‚è¨','‚óÄÔ∏è','üîº','üîΩ','‚û°Ô∏è','‚¨ÖÔ∏è','‚¨ÜÔ∏è','‚¨áÔ∏è','‚ÜóÔ∏è','‚ÜòÔ∏è','‚ÜôÔ∏è','‚ÜñÔ∏è','‚ÜïÔ∏è','‚ÜîÔ∏è','‚Ü™Ô∏è','‚Ü©Ô∏è','‚§¥Ô∏è','‚§µÔ∏è','üîÄ','üîÅ','üîÇ','üîÑ','üîÉ','‚ûø','üîö','üîô','üîõ','üîù','üîú','‚úîÔ∏è','‚òëÔ∏è','üîò','üî¥','üü†','üü°','üü¢','üîµ','üü£','‚ö´','‚ö™','üü§','üî∫','üîª','üî∏','üîπ','üî∂','üî∑','üî≥','üî≤','‚ñ™Ô∏è','‚ñ´Ô∏è','‚óæ','‚óΩ','‚óºÔ∏è','‚óªÔ∏è','üü•','üüß','üü®','üü©','üü¶','üü™','‚¨õ','‚¨ú','üü´','üîà','üîá','üîâ','üîä','üîî','üîï','üì£','üì¢','üëÅÔ∏è‚Äçüó®Ô∏è','üí¨','üí≠','üóØÔ∏è','‚ô†Ô∏è','‚ô£Ô∏è','‚ô•Ô∏è','‚ô¶Ô∏è','üÉè','üé¥','üÄÑ']
      },
      'Weather': {
        icon: '‚òÄÔ∏è',
        emojis: ['‚òÄÔ∏è','üå§Ô∏è','‚õÖ','üå•Ô∏è','‚òÅÔ∏è','üå¶Ô∏è','üåßÔ∏è','‚õàÔ∏è','üå©Ô∏è','üå®Ô∏è','‚ùÑÔ∏è','üå¨Ô∏è','üí®','üå™Ô∏è','üå´Ô∏è','üåà','‚òî','‚ö°','‚ùÑÔ∏è','üî•','üíß','üåä','‚≠ê','üåü','‚ú®','üí´','üåô','üåõ','üåú','üåù','üåû','ü™ê','‚ö°','‚òÑÔ∏è','üåç','üåé','üåè','üåë','üåí','üåì','üåî','üåï','üåñ','üåó','üåò']
      },
      'Flags': {
        icon: 'üè≥Ô∏è',
        emojis: ['üè≥Ô∏è','üè¥','üè¥‚Äç‚ò†Ô∏è','üèÅ','üö©','üéå','üè≥Ô∏è‚Äçüåà','üè≥Ô∏è‚Äç‚ößÔ∏è','üá∫üá∏','üá¨üáß','üá®üá¶','üá¶üá∫','üá´üá∑','üá©üá™','üáÆüáπ','üá™üá∏','üáØüáµ','üá∞üá∑','üá®üá≥','üáÆüá≥','üáßüá∑','üá≤üáΩ','üá∑üá∫','üáøüá¶','üá≥üá±','üáßüá™','üá®üá≠','üá¶üáπ','üá∏üá™','üá≥üá¥','üá©üá∞','üá´üáÆ','üáµüá±','üáÆüá™','üáµüáπ','üá¨üá∑','üáπüá∑','üá™üá¨','üáÆüá±','üá∏üá¶','üá¶üá™','üáπüá≠','üáªüá≥','üáÆüá©','üáµüá≠','üá≤üáæ','üá∏üá¨','üá≥üáø','üá¶üá∑','üá®üá±','üá®üá¥','üáµüá™','üáªüá™']
      }
    };

    // Track recently used emojis
    let recentEmojis = JSON.parse(localStorage.getItem('cnmn-recent-emojis') || '[]');
    let currentEmojiCategory = 'Smileys';
    let emojiSearchQuery = '';
    let emojiKeywords = null;

    // Load emoji keyword data from CDN
    async function loadEmojiData() {
      try {
        const resp = await fetch('https://cdn.jsdelivr.net/npm/emojilib@4.0.2/dist/emoji-en-US.json');
        if (resp.ok) emojiKeywords = await resp.json();
      } catch (e) {
        console.warn('Failed to load emoji data:', e);
      }
    }

    // Load models from server
    async function loadModels() {
      const status = document.getElementById('modelStatus');
      const select = document.getElementById('modelSelect');
      try {
        const response = await fetch('/api/models');
        const data = await response.json();

        select.innerHTML = '';

        // Add AI models
        const modelEntries = Object.entries(data.models || {});
        for (const [id, meta] of modelEntries) {
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = meta.name;
          select.appendChild(opt);
        }

        // Always add rule-based option at the end
        const rulesOpt = document.createElement('option');
        rulesOpt.value = 'rules';
        rulesOpt.textContent = 'Rule-Based (no AI)';
        select.appendChild(rulesOpt);

        if (modelEntries.length > 0) {
          // Prefer Sonnet 4.5 as default, fall back to first available
          const preferredModel = modelEntries.find(([id]) => id.includes('sonnet'));
          currentModel = preferredModel ? preferredModel[0] : modelEntries[0][0];
          select.value = currentModel;
          status.textContent = data.portkey ? 'via Portkey' : '';
        } else {
          currentModel = 'rules';
          select.value = 'rules';
          status.textContent = 'No AI configured ‚Äî using rules';
        }
      } catch (e) {
        select.innerHTML = '<option value="rules">Rule-Based (no AI)</option>';
        currentModel = 'rules';
        status.textContent = 'Server offline ‚Äî using rules';
      }
    }

    function selectModel() {
      currentModel = document.getElementById('modelSelect').value;
    }

    // ============================================
    // DISGUISE GENERATION & VALIDATION
    // ============================================

    // Validation guardrails for disguises
    const DisguiseValidator = {
      // Check basic format requirements
      isValidFormat(disguise) {
        if (!disguise || typeof disguise !== 'string') return { valid: false, reason: 'Empty or invalid' };
        const d = disguise.toLowerCase().trim();
        if (d.length < 2) return { valid: false, reason: 'Too short (< 2 chars)' };
        if (d.length > 10) return { valid: false, reason: 'Too long (> 10 chars)' };
        if (!/^[a-z]+$/.test(d)) return { valid: false, reason: 'Contains non-letter characters' };
        return { valid: true };
      },

      // Check if disguise is too similar to original word
      isTooSimilarToWord(disguise, word) {
        const d = disguise.toLowerCase();
        const w = word.toLowerCase();
        if (d === w) return { valid: false, reason: 'Identical to original word' };
        if (w.includes(d) && d.length > 2) return { valid: false, reason: 'Word contains disguise as substring' };
        if (d.includes(w)) return { valid: false, reason: 'Disguise contains word as substring' };
        return { valid: true };
      },

      // Check answer disguise
      validateAnswerDisguise(disguise, word) {
        const formatCheck = this.isValidFormat(disguise);
        if (!formatCheck.valid) return formatCheck;

        const similarCheck = this.isTooSimilarToWord(disguise, word);
        if (!similarCheck.valid) return similarCheck;

        return { valid: true };
      },

      // Check distractor disguise
      validateDistractor(distractor, answerDisguise, answerWord, prompt, allDisguises = []) {
        const formatCheck = this.isValidFormat(distractor);
        if (!formatCheck.valid) return formatCheck;

        const d = distractor.toLowerCase();
        const ans = answerDisguise.toLowerCase();
        const ansWord = answerWord.toLowerCase();
        const p = prompt.toLowerCase();

        // Can't match the answer disguise
        if (d === ans) return { valid: false, reason: 'Identical to answer disguise' };

        // Can't be the answer word's consonants exactly
        const ansConsonants = ansWord.replace(/[aeiou]/g, '');
        if (d === ansConsonants) return { valid: false, reason: 'Matches answer consonant pattern' };

        // Can't be the prompt's consonants
        const promptConsonants = p.replace(/[aeiou]/g, '');
        if (d === promptConsonants) return { valid: false, reason: 'Matches prompt consonant pattern' };

        // Can't duplicate another distractor
        if (allDisguises.some(existing => existing.toLowerCase() === d)) {
          return { valid: false, reason: 'Duplicate of another option' };
        }

        // Length should be within ¬±3 of answer disguise
        if (Math.abs(d.length - ans.length) > 3) {
          return { valid: false, reason: `Length too different from answer (${d.length} vs ${ans.length})` };
        }

        return { valid: true };
      },

      // Validate all options together
      validateOptionSet(answerDisguise, distractors) {
        const all = [answerDisguise, ...distractors].map(d => d.toLowerCase());

        // Check for duplicates
        const unique = new Set(all);
        if (unique.size !== all.length) {
          return { valid: false, reason: 'Duplicate disguises in option set' };
        }

        // Check no option is substring of another
        for (let i = 0; i < all.length; i++) {
          for (let j = 0; j < all.length; j++) {
            if (i !== j && all[j].includes(all[i]) && all[i].length > 2) {
              return { valid: false, reason: `"${all[i]}" is substring of "${all[j]}"` };
            }
          }
        }

        return { valid: true };
      }
    };

    // Rule-based disguise (fallback)
    function generateDisguiseRuleBased(word) {
      if (!word) return '';
      const lower = word.toLowerCase();
      let disguise = lower
        .replace(/tion$/i, 'shn')
        .replace(/sion$/i, 'zhn')
        .replace(/age$/i, 'j')
        .replace(/dge$/i, 'j')
        .replace(/ght$/i, 't')
        .replace(/ck/g, 'k')
        .replace(/ph/g, 'f')
        .replace(/wh/g, 'w')
        .replace(/wr/g, 'r')
        .replace(/kn/g, 'n')
        .replace(/[aeiou]/g, '');

      if (disguise.length < 2) {
        disguise = lower.replace(/[aeiou](?=[aeiou])/g, '').replace(/[aeiou]$/g, '');
      }
      return disguise || lower.substring(0, 3);
    }

    // LLM-based disguise generation with validation
    async function generateDisguiseLLM(word, existingDisguises = [], maxRetries = 3) {
      const prompt = `Create a phonetic "disguise" for the word "${word}".

Rules:
- Remove or reduce vowels
- Use phonetic shortcuts (tion‚Üíshn, ph‚Üíf, ck‚Üík, etc.)
- Result should SOUND like the word when read aloud
- Keep it 2-8 characters, lowercase letters only
- Example: "garage" ‚Üí "grj", "phone" ‚Üí "fon", "knight" ‚Üí "nyt"

${existingDisguises.length > 0 ? `Avoid these existing disguises: ${existingDisguises.join(', ')}` : ''}

Return ONLY the disguise, nothing else.`;

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const response = await callServer(prompt);
          const disguise = response.trim().toLowerCase().replace(/[^a-z]/g, '');

          const validation = DisguiseValidator.validateAnswerDisguise(disguise, word);
          if (validation.valid && !existingDisguises.includes(disguise)) {
            return disguise;
          }
          console.log(`Disguise attempt ${attempt + 1} rejected: ${disguise} - ${validation.reason || 'duplicate'}`);
        } catch (e) {
          console.log(`Disguise generation failed: ${e.message}`);
        }
      }

      // Fallback to rule-based
      return generateDisguiseRuleBased(word);
    }

    // Generate distractors with validation
    async function generateDistractorsLLM(prompt, answerWord, answerDisguise, maxRetries = 3) {
      const llmPrompt = `Generate 3 distractor disguises for a word puzzle.

The prompt is "${prompt}" and the correct answer is "${answerWord}" (disguised as "${answerDisguise}").

Create 3 WRONG answers that:
1. Look similar to plausible word disguises
2. Are NOT the correct answer or its synonyms
3. Are tempting but wrong guesses
4. Are 2-8 lowercase letters each

For each, provide the disguise and what fake word it might represent.

Format as JSON array:
[{"disguise": "xyz", "fakeWord": "SOMEWORD", "type": "wrong-letters"},...]

Types: "wrong-letters" (plausible but decodes wrong), "non-synonym" (real word, not a synonym)

Return ONLY the JSON array.`;

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
          const response = await callServer(llmPrompt);
          const jsonMatch = response.match(/\[[\s\S]*\]/);
          if (!jsonMatch) continue;

          const parsed = JSON.parse(jsonMatch[0]);
          const validDistractors = [];
          const usedDisguises = [answerDisguise];

          for (const d of parsed) {
            if (validDistractors.length >= 3) break;
            const disguise = (d.disguise || '').toLowerCase().replace(/[^a-z]/g, '');

            const validation = DisguiseValidator.validateDistractor(
              disguise, answerDisguise, answerWord, prompt, usedDisguises
            );

            if (validation.valid) {
              validDistractors.push({
                word: (d.fakeWord || 'UNKNOWN').toUpperCase(),
                disguise: disguise,
                type: d.type || 'non-synonym'
              });
              usedDisguises.push(disguise);
            } else {
              console.log(`Distractor rejected: ${disguise} - ${validation.reason}`);
            }
          }

          if (validDistractors.length >= 3) {
            // Final validation of the complete set
            const setValidation = DisguiseValidator.validateOptionSet(
              answerDisguise,
              validDistractors.map(d => d.disguise)
            );
            if (setValidation.valid) {
              return validDistractors;
            }
            console.log(`Option set rejected: ${setValidation.reason}`);
          }
        } catch (e) {
          console.log(`Distractor generation attempt ${attempt + 1} failed: ${e.message}`);
        }
      }

      // Fallback: generate rule-based distractors
      return generateDistractorsFallback(answerWord, answerDisguise);
    }

    // Fallback distractor generation
    function generateDistractorsFallback(answerWord, answerDisguise) {
      const variations = [
        answerDisguise.split('').reverse().join(''),
        answerDisguise.slice(0, -1) + 'x',
        'x' + answerDisguise.slice(1),
        answerDisguise.replace(/./g, (c, i) => i === Math.floor(answerDisguise.length/2) ? 'z' : c)
      ].filter(d => d !== answerDisguise && d.length >= 2);

      return variations.slice(0, 3).map((d, i) => ({
        word: 'EDIT_ME',
        disguise: d,
        type: ['wrong-letters', 'non-synonym', 'wrong-letters'][i]
      }));
    }

    // Main disguise function (synchronous, rule-based)
    function generateDisguise(word) {
      return generateDisguiseRuleBased(word);
    }

    // Generate full quiz
    async function generateQuiz() {
      const theme = document.getElementById('themeInput').value.trim();
      if (!theme) {
        alert('Please enter a theme');
        return;
      }

      quiz.theme = theme;
      const container = document.getElementById('questionsContainer');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Generating quiz...</div>';
      document.getElementById('exportSection').classList.add('hidden');

      try {
        if (currentModel === 'rules') {
          quiz.questions = generateRuleBasedQuiz(theme);
        } else {
          quiz.questions = await generateChainQuiz(theme);
        }

        // Reset picker state for new generation
        pickerMode = {};
        iconResults = {};

        // Phase 1: Immediate render with emoji fallbacks (so UI isn't blocked)
        for (const q of quiz.questions) {
          if (!q.emoji) {
            const matches = findEmojiForWord(q.prompt);
            if (matches.length > 0) q.emoji = matches[0];
          }
        }
        renderQuestions();
        document.getElementById('exportSection').classList.remove('hidden');

        // Phase 2: Async icon fetch, then re-render with icons
        container.insertAdjacentHTML('afterbegin',
          '<div class="loading" id="image-fetch-hint" style="padding:8px;margin-bottom:8px"><div class="spinner"></div>Fetching icons...</div>');
        await autoFetchIcons();
        const hint = document.getElementById('image-fetch-hint');
        if (hint) hint.remove();
        renderQuestions();

        // Phase 3: LLM-assisted retry for failed icon searches
        if (currentModel !== 'rules') {
          await retryFailedIcons();
        }
      } catch (error) {
        container.innerHTML = `<div class="empty-state"><h3>Error</h3><p>${error.message}</p></div>`;
      }
    }

    // Rule-based quiz generation (fallback)
    function generateRuleBasedQuiz(theme) {
      const themeData = {
        'buildings': [
          { prompt: 'shed', answer: 'GARAGE', distractors: ['LEAN-TO', 'PORCH', 'SHACK'] },
          { prompt: 'home', answer: 'HOUSE', distractors: ['HUT', 'TENT', 'DOME'] },
          { prompt: 'inn', answer: 'HOTEL', distractors: ['MOTEL', 'HOSTEL', 'LODGE'] },
          { prompt: 'church', answer: 'CHAPEL', distractors: ['TEMPLE', 'SHRINE', 'MOSQUE'] },
          { prompt: 'shop', answer: 'STORE', distractors: ['MARKET', 'MALL', 'BOOTH'] },
          { prompt: 'castle', answer: 'FORTRESS', distractors: ['PALACE', 'MANOR', 'TOWER'] },
        ],
        'emotions': [
          { prompt: 'happy', answer: 'JOYFUL', distractors: ['GLAD', 'MERRY', 'PLEASED'] },
          { prompt: 'sad', answer: 'GLOOMY', distractors: ['MOODY', 'DREARY', 'SOMBER'] },
          { prompt: 'angry', answer: 'FURIOUS', distractors: ['ANNOYED', 'IRATE', 'CROSS'] },
          { prompt: 'scared', answer: 'AFRAID', distractors: ['NERVOUS', 'WORRIED', 'ANXIOUS'] },
          { prompt: 'calm', answer: 'SERENE', distractors: ['PEACEFUL', 'QUIET', 'STILL'] },
          { prompt: 'tired', answer: 'WEARY', distractors: ['SLEEPY', 'DROWSY', 'FATIGUED'] },
        ],
        'weather': [
          { prompt: 'rain', answer: 'SHOWER', distractors: ['DRIZZLE', 'SPRINKLE', 'DOWNPOUR'] },
          { prompt: 'wind', answer: 'BREEZE', distractors: ['GUST', 'DRAFT', 'GALE'] },
          { prompt: 'storm', answer: 'TEMPEST', distractors: ['SQUALL', 'CYCLONE', 'TYPHOON'] },
          { prompt: 'fog', answer: 'MIST', distractors: ['HAZE', 'SMOG', 'VAPOR'] },
          { prompt: 'snow', answer: 'FLURRY', distractors: ['SLEET', 'FROST', 'BLIZZARD'] },
          { prompt: 'sun', answer: 'SHINE', distractors: ['GLOW', 'BEAM', 'GLARE'] },
        ],
      };

      // Find matching theme or use default
      const lowerTheme = theme.toLowerCase();
      let data = null;
      for (const [key, value] of Object.entries(themeData)) {
        if (lowerTheme.includes(key) || key.includes(lowerTheme)) {
          data = value;
          break;
        }
      }

      if (!data) {
        // Generate placeholder data
        data = Array(6).fill(null).map((_, i) => ({
          prompt: `word${i + 1}`,
          answer: `ANSWER${i + 1}`,
          distractors: [`WRONG${i}A`, `WRONG${i}B`, `WRONG${i}C`]
        }));
      }

      return data.map(q => ({
        prompt: q.prompt,
        emoji: '',
        rejectedPrompts: [],
        answer: { word: q.answer, disguise: generateDisguise(q.answer) },
        rejectedAnswers: [],
        distractors: q.distractors.map((d, i) => ({
          word: d,
          disguise: generateDisguise(d),
          type: ['wrong-letters', 'non-synonym', 'non-synonym'][i % 3]
        })),
        rejectedDistractors: []
      }));
    }

    // AI quiz generation
    async function generateAIQuiz(theme) {
      const prompt = `Generate 6 synonym quiz questions for the theme "${theme}".

For each question provide:
1. A prompt word (common word)
2. An answer word (synonym of prompt)
3. Three distractor words with their types (use ONLY these two types):
   - wrong-letters: a plausible-looking consonant pattern that doesn't quite decode to a real word
   - non-synonym: a valid word in the same category but NOT a synonym of the prompt

Format as JSON array:
[
  {
    "prompt": "shed",
    "answer": "GARAGE",
    "distractors": [
      {"word": "LEAN-TO", "type": "wrong-letters"},
      {"word": "PORCH", "type": "non-synonym"},
      {"word": "SHACK", "type": "phonetic-trap"}
    ]
  }
]

Return ONLY the JSON array, no other text.`;

      const response = await callServer(prompt);

      // Parse JSON from response
      let parsed;
      try {
        // Try to extract JSON from response
        const jsonMatch = response.match(/\[[\s\S]*\]/);
        if (jsonMatch) {
          parsed = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (e) {
        console.error('Failed to parse AI response:', response);
        throw new Error('Failed to parse AI response. Try again or use Rule-Based mode.');
      }

      const questions = [];

      for (const q of parsed.slice(0, 6)) {
        const answerWord = (q.answer || '').toUpperCase();
        const promptWord = q.prompt || '';

        // Use LLM for smarter disguises with validation
        const answerDisguise = await generateDisguiseLLM(answerWord);
        const distractors = await generateDistractorsLLM(promptWord, answerWord, answerDisguise);

        questions.push({
          prompt: promptWord,
          emoji: '',
          rejectedPrompts: [],
          answer: {
            word: answerWord,
            disguise: answerDisguise
          },
          rejectedAnswers: [],
          distractors: distractors,
          rejectedDistractors: []
        });
      }

      return questions;
    }

    // Single-call AI quiz generation with difficulty scaling
    async function generateChainQuiz(theme) {
      const chainPrompt = `You are a puzzle designer for **CNMN**, a daily word puzzle game. Generate 6 puzzles on the theme "${theme}" with increasing difficulty.

### How It Works

Each puzzle has:
- A **prompt**: a SINGLE WORD related to the theme (e.g., for theme "weather": "rain", "wind", "storm")
- A **hidden answer word**: a SINGLE WORD that is a synonym of the prompt (e.g., prompt "rain" ‚Üí answer "SHOWER")
- A **compressed clue**: the answer word with vowels removed / phonetically shortened (e.g., "SHOWER" ‚Üí "shwr")
- **3 distractors**: SINGLE WORDS that are **NOT synonyms of the prompt** ‚Äî they should be words from a different part of the theme or unrelated words

The player sees the prompt and 4 compressed options. Only one decodes to a synonym of the prompt. The other 3 decode to words that are NOT synonyms of the prompt.

### CRITICAL RULES

1. **Prompts and answers must be SINGLE WORDS** ‚Äî never phrases. "rain" ‚úÖ, "farming tasks" ‚ùå, "sowing seeds" ‚ùå
2. **The answer must be a true synonym of the prompt.** prompt "happy" ‚Üí answer "JOYFUL" ‚úÖ
3. **The answer is NEVER the prompt word itself.** prompt "rain" ‚Üí answer "RAIN" ‚ùå
4. **Distractors must NOT be synonyms of the prompt.** If the prompt is "rain", distractors cannot be "drizzle", "downpour", "shower" ‚Äî those are all correct answers! Distractors should be unrelated words like "BREEZE", "FLAME", "PEBBLE".
5. **Every compressed clue must be unambiguous** ‚Äî only one common English word matches.

### Compression Rules

Phonetic shorthand ‚Äî not just vowel removal:
- Remove most vowels, keep sonically essential ones (\`kloz\` for "clothes")
- Phonetic substitutions: \`ph\`‚Üí\`f\`, \`ght\`‚Üí\`t\`, \`tion\`‚Üí\`shn\`, \`ck\`‚Üí\`k\`
- Drop silent letters: "knife" ‚Üí \`nif\`

Examples: clothes‚Üí\`kloz\`, cinnamon‚Üí\`cnmn\`, garbage‚Üí\`grbj\`, happy‚Üí\`hpy\`

### Difficulty Scaling

**Questions 1‚Äì2 (easy):** Common words, simple vowel removal, distractors obviously wrong
**Questions 3‚Äì4 (medium):** Compressed clue looks like multiple words; specific letters disambiguate
**Questions 5‚Äì6 (hard):** Phonetic spelling + extreme compression

### Output Format (return ONLY this JSON, no other text):

\`\`\`json
{
  "chain": [
    {
      "link": 1,
      "difficulty": "easy",
      "category": "rain",
      "icon_search": "rain cloud",
      "compressed": "shwr",
      "answer_word": "shower",
      "correct_option": "Shower",
      "distractors": ["Breeze", "Flame", "Pebble"]
    }
  ]
}
\`\`\`

- "category" = the single-word prompt shown to the player
- "icon_search" = a 1-3 word search term to find a visual icon for this prompt. Use concrete, picturable nouns (e.g., for "scared" use "fearful face", for "inn" use "hotel building", for "swift" use "running cheetah"). Avoid abstract words.
- "answer_word" = the single word the compressed clue decodes to (must be a synonym of category)
- "correct_option" = the answer as shown to the player (same word, can be capitalized)
- "distractors" = 3 single words that are NOT synonyms of the category

Generate 6 puzzles on the theme "${theme}". Return ONLY the JSON.`;

      const response = await callServer(chainPrompt, { maxTokens: 4096 });

      // Parse JSON from response
      let parsed;
      try {
        const jsonMatch = response.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          parsed = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (e) {
        console.error('Failed to parse chain response:', response);
        throw new Error('Failed to parse AI response. Try again or use Rule-Based mode.');
      }

      const chain = parsed.chain;
      if (!chain || !Array.isArray(chain) || chain.length === 0) {
        throw new Error('Invalid format in AI response. Try again.');
      }

      const questions = [];
      for (const link of chain.slice(0, 6)) {
        const answerWord = (link.answer_word || '').toUpperCase();
        const answerDisguise = (link.compressed || '').toLowerCase();
        const distractorWords = link.distractors || [];

        // Generate disguises for each distractor using rule-based compression
        const distractors = distractorWords.slice(0, 3).map((word, i) => ({
          word: (word || '').toUpperCase(),
          disguise: generateDisguiseRuleBased(word || ''),
          type: ['wrong-letters', 'non-synonym', 'non-synonym'][i % 3]
        }));

        // Pad if fewer than 3 distractors
        while (distractors.length < 3) {
          distractors.push({ word: 'EDIT_ME', disguise: 'dtm', type: 'non-synonym' });
        }

        questions.push({
          prompt: (link.category || '').toLowerCase(),
          emoji: '',
          iconSearch: link.icon_search || (link.category || '').toLowerCase(),
          rejectedPrompts: [],
          answer: {
            word: answerWord,
            disguise: answerDisguise
          },
          rejectedAnswers: [],
          distractors: distractors,
          rejectedDistractors: [],
          correctOption: link.correct_option || null,
          difficulty: link.difficulty || null,
        });
      }

      return questions;
    }

    // Render all questions
    function renderQuestions() {
      const container = document.getElementById('questionsContainer');
      container.innerHTML = quiz.questions.map((q, i) => renderQuestionCard(q, i)).join('');
    }

    // Render single question card
    function renderQuestionCard(q, index) {
      const difficultyBadge = q.difficulty
        ? `<span class="difficulty-badge ${q.difficulty}">${q.difficulty}</span>`
        : '';

      return `
        <div class="question-card" id="question-${index}">
          <h3><span class="num">${index + 1}</span> Question ${difficultyBadge}</h3>

          <div class="field-row">
            <label>Prompt:</label>
            <div class="emoji-picker-container">
              ${q.iconRetrying
                ? `<button type="button" class="emoji-btn retrying"><span class="icon-retry-spinner"></span></button>`
                : q.imageUrl
                  ? `<div class="image-preview" onclick="toggleEmojiPicker(${index})"><img src="${q.imageUrl}" alt=""></div>`
                  : `<button type="button" class="emoji-btn" onclick="toggleEmojiPicker(${index})">${q.emoji || '‚ûï'}</button>`
              }
              <div class="emoji-dropdown" id="emoji-dropdown-${index}">
                <div class="image-picker-toggle">
                  <button type="button" class="${(pickerMode[index] || 'icon') === 'emoji' ? 'active' : ''}" onclick="setPickerMode(${index}, 'emoji')">Emoji</button>
                  <button type="button" class="${(pickerMode[index] || 'icon') === 'icon' ? 'active' : ''}" onclick="setPickerMode(${index}, 'icon')">Icon</button>
                </div>
                <div id="picker-emoji-${index}" style="display:${(pickerMode[index] || 'icon') === 'emoji' ? 'block' : 'none'}">
                  <div class="emoji-search">
                    <input type="text" placeholder="Search emojis..." oninput="filterEmojis(${index}, this.value)" id="emoji-search-${index}">
                  </div>
                  <div class="emoji-tabs" id="emoji-tabs-${index}">
                    ${Object.entries(emojiCategories).map(([name, cat]) =>
                      `<button type="button" class="emoji-tab ${name === currentEmojiCategory ? 'active' : ''}" onclick="switchEmojiCategory(${index}, '${name}')" title="${name}">${cat.icon}</button>`
                    ).join('')}
                  </div>
                  <div class="emoji-grid-container" id="emoji-grid-${index}">
                    ${renderEmojiGrid(index)}
                  </div>
                  <div class="emoji-footer">
                    <button type="button" class="emoji-clear" onclick="selectEmoji(${index}, '')">Clear</button>
                    <button type="button" class="emoji-ai-suggest" id="emoji-ai-btn-${index}" onclick="suggestEmojiAI(${index})" ${currentModel === 'rules' ? 'disabled title="Not available with rule-based provider"' : ''}>Ask AI</button>
                    <input type="text" class="emoji-direct-input" placeholder="Paste any emoji" id="emoji-direct-${index}" onkeydown="handleDirectEmoji(event, ${index})" maxlength="2">
                  </div>
                </div>
                <div id="picker-icon-${index}" style="display:${(pickerMode[index] || 'icon') === 'icon' ? 'block' : 'none'}">
                  <div class="icon-search-row">
                    <input type="text" placeholder="Search icons..." id="icon-search-${index}"
                      value="${q.iconSearch || q.prompt || ''}"
                      onkeydown="if(event.key==='Enter'){searchIcons(${index});event.preventDefault()}">
                    <button type="button" onclick="searchIcons(${index})">Search</button>
                  </div>
                  <div class="icon-grid" id="icon-grid-${index}">
                    ${renderIconGrid(index)}
                  </div>
                  <div class="icon-footer">
                    <button type="button" class="emoji-clear" onclick="clearImage(${index})">Clear icon</button>
                    <span>Icons by Iconify</span>
                  </div>
                </div>
              </div>
            </div>
            <input type="text" value="${q.prompt}" onchange="updatePrompt(${index}, this.value)" />
            <button class="small" onclick="reshufflePrompt(${index})">üîÑ</button>
            ${q.iconRetryLog && q.iconRetryLog.length > 0
              ? `<button type="button" class="icon-retry-log-btn" onclick="toggleRetryLog(${index})">log (${q.iconRetryLog.length})</button>`
              : ''}
          </div>
          ${q.iconRetryLog && q.iconRetryLog.length > 0
            ? `<div class="icon-retry-log hidden" id="retry-log-${index}">${q.iconRetryLog.map(e =>
                `<div class="log-entry ${e.ok ? 'log-ok' : e.skipped ? 'log-skip' : 'log-fail'}">${e.text}</div>`
              ).join('')}</div>`
            : ''}

          <div class="field-row">
            <label>Answer:</label>
            <input type="text" value="${q.answer.word}" onchange="updateAnswer(${index}, this.value)" />
            <input type="text" class="disguise-input" value="${q.answer.disguise}" onchange="updateAnswerDisguise(${index}, this.value)" title="Edit clue" />
            <button class="small" onclick="reshuffleAnswer(${index})">üîÑ</button>
          </div>

          <div class="distractors-section">
            <div class="distractors-header">
              <label>Distractors:</label>
              <button class="small secondary" onclick="reshuffleAllDistractors(${index})">üîÑ All</button>
            </div>
            ${q.distractors.map((d, di) => `
              <div class="field-row">
                <input type="text" value="${d.word}" onchange="updateDistractor(${index}, ${di}, this.value)" style="flex:1" />
                <input type="text" class="disguise-input" value="${d.disguise}" onchange="updateDistractorDisguise(${index}, ${di}, this.value)" title="Edit clue" />
                <span class="type-badge clickable ${d.type}" onclick="cycleType(${index}, ${di})" title="Click to change type">${d.type}</span>
                <button class="small" onclick="reshuffleDistractor(${index}, ${di})">üîÑ</button>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    // Find emojis matching a word using emojilib keywords
    function findEmojiForWord(word) {
      if (!emojiKeywords || !word) return [];
      const lower = word.toLowerCase().replace(/[^a-z]/g, '');
      if (!lower) return [];
      const exact = [];
      const partial = [];
      for (const [emoji, keywords] of Object.entries(emojiKeywords)) {
        for (const kw of keywords) {
          if (kw === lower) { exact.push(emoji); break; }
          if (kw.includes(lower) || lower.includes(kw)) { partial.push(emoji); break; }
        }
      }
      return [...exact, ...partial.filter(e => !exact.includes(e))];
    }

    // Emoji picker functions
    function renderEmojiGrid(qIndex, searchQuery = '') {
      if (searchQuery) {
        if (!emojiKeywords) {
          return '<div class="emoji-no-results">Search loading\u2026</div>';
        }
        const q = searchQuery.toLowerCase();
        const results = [];
        for (const [emoji, keywords] of Object.entries(emojiKeywords)) {
          if (results.length >= 64) break;
          if (keywords.some(kw => kw.includes(q))) results.push(emoji);
        }
        if (results.length === 0) {
          return '<div class="emoji-no-results">No emojis found</div>';
        }
        return `
          <div class="emoji-grid">
            ${results.map(e => `<button type="button" class="emoji-option" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
          </div>
        `;
      }

      let html = '';

      // Show suggested emojis based on the question's prompt word
      if (quiz && quiz.questions && quiz.questions[qIndex]) {
        const promptWord = quiz.questions[qIndex].prompt;
        const suggested = findEmojiForWord(promptWord).slice(0, 8);
        if (suggested.length > 0) {
          html += `
            <div class="emoji-section-label">Suggested</div>
            <div class="emoji-grid">
              ${suggested.map(e => `<button type="button" class="emoji-option suggested" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
            </div>
          `;
        }
      }

      // Show recent emojis if any
      if (recentEmojis.length > 0) {
        html += `
          <div class="emoji-section-label">Recent</div>
          <div class="emoji-grid">
            ${recentEmojis.slice(0, 16).map(e => `<button type="button" class="emoji-option" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
          </div>
        `;
      }

      // Show current category
      const cat = emojiCategories[currentEmojiCategory];
      if (cat) {
        html += `
          <div class="emoji-section-label">${currentEmojiCategory}</div>
          <div class="emoji-grid">
            ${cat.emojis.map(e => `<button type="button" class="emoji-option" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
          </div>
        `;
      }

      return html;
    }

    function toggleRetryLog(qIndex) {
      const el = document.getElementById(`retry-log-${qIndex}`);
      if (el) el.classList.toggle('hidden');
    }

    function toggleEmojiPicker(qIndex) {
      // Close any other open pickers
      document.querySelectorAll('.emoji-dropdown.open').forEach(el => {
        if (el.id !== `emoji-dropdown-${qIndex}`) {
          el.classList.remove('open');
        }
      });
      const dropdown = document.getElementById(`emoji-dropdown-${qIndex}`);
      const isOpening = !dropdown.classList.contains('open');
      dropdown.classList.toggle('open');

      // Reset search when opening
      if (isOpening) {
        const searchInput = document.getElementById(`emoji-search-${qIndex}`);
        if (searchInput) {
          searchInput.value = '';
          emojiSearchQuery = '';
        }
        updateEmojiGrid(qIndex);
      }
    }

    function switchEmojiCategory(qIndex, category) {
      currentEmojiCategory = category;
      // Update active tab
      const tabsContainer = document.getElementById(`emoji-tabs-${qIndex}`);
      tabsContainer.querySelectorAll('.emoji-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      // Clear search
      const searchInput = document.getElementById(`emoji-search-${qIndex}`);
      if (searchInput) searchInput.value = '';
      emojiSearchQuery = '';
      // Update grid
      updateEmojiGrid(qIndex);
    }

    function filterEmojis(qIndex, query) {
      emojiSearchQuery = query.toLowerCase();
      updateEmojiGrid(qIndex);
    }

    function updateEmojiGrid(qIndex) {
      const gridContainer = document.getElementById(`emoji-grid-${qIndex}`);
      if (gridContainer) {
        gridContainer.innerHTML = renderEmojiGrid(qIndex, emojiSearchQuery);
      }
    }

    function selectEmoji(qIndex, emoji) {
      quiz.questions[qIndex].emoji = emoji;
      document.getElementById(`emoji-dropdown-${qIndex}`).classList.remove('open');

      // Add to recent emojis
      if (emoji) {
        recentEmojis = [emoji, ...recentEmojis.filter(e => e !== emoji)].slice(0, 16);
        localStorage.setItem('cnmn-recent-emojis', JSON.stringify(recentEmojis));
      }

      renderQuestions();
    }

    function handleDirectEmoji(event, qIndex) {
      if (event.key === 'Enter') {
        const input = document.getElementById(`emoji-direct-${qIndex}`);
        const emoji = input.value.trim();
        if (emoji) {
          selectEmoji(qIndex, emoji);
        }
      }
    }

    async function suggestEmojiAI(qIndex) {
      const btn = document.getElementById(`emoji-ai-btn-${qIndex}`);
      if (!btn || btn.disabled) return;
      const q = quiz.questions[qIndex];
      btn.disabled = true;
      btn.textContent = 'Thinking\u2026';
      try {
        const result = await callServer(
          `Reply with ONLY a single emoji (no text) that best represents the word "${q.prompt}" (synonym: ${q.answer.word}).`
        );
        const emoji = result.trim().replace(/[^\p{Emoji}]/gu, '').slice(0, 2);
        if (emoji) selectEmoji(qIndex, emoji);
      } catch (e) {
        console.warn('AI emoji suggestion failed:', e);
      } finally {
        btn.disabled = currentModel === 'rules';
        btn.textContent = 'Ask AI';
      }
    }

    // Close emoji picker when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.emoji-picker-container')) {
        document.querySelectorAll('.emoji-dropdown.open').forEach(el => {
          el.classList.remove('open');
        });
      }
    });

    // ============================================
    // ICONIFY ICON PICKER
    // ============================================
    let pickerMode = {};     // qIndex -> 'emoji' | 'icon'
    let iconResults = {};    // qIndex -> array of { prefix, name }

    // Preferred icon set order (colored first, then monochrome)
    const ICON_SET_PRIORITY = ['noto', 'twemoji', 'fluent-emoji-flat', 'fluent-emoji-high-contrast', 'game-icons'];
    const ICON_SET_NAMES = {
      'noto': 'Noto Emoji (Google)',
      'twemoji': 'Twemoji (Twitter)',
      'fluent-emoji-flat': 'Fluent Emoji (Microsoft)',
      'fluent-emoji-high-contrast': 'Fluent Emoji HC',
      'game-icons': 'Game Icons',
    };

    // Search Iconify API for icons matching a query.
    // Returns { icons, best } or null if no results.
    async function searchIconify(query) {
      try {
        const prefixes = ICON_SET_PRIORITY.join(',');
        const resp = await fetch(`https://api.iconify.design/search?query=${encodeURIComponent(query)}&prefixes=${prefixes}&limit=32`);
        const data = await resp.json();
        if (!data.icons || data.icons.length === 0) return null;

        const icons = data.icons.map(icon => {
          const colonIdx = icon.indexOf(':');
          return { prefix: icon.substring(0, colonIdx), name: icon.substring(colonIdx + 1) };
        });
        icons.sort((a, b) => {
          const ai = ICON_SET_PRIORITY.indexOf(a.prefix);
          const bi = ICON_SET_PRIORITY.indexOf(b.prefix);
          return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);
        });

        return { icons, best: icons[0] };
      } catch {
        return null;
      }
    }

    // Auto-fetch Iconify icons for all quiz questions in parallel.
    // Falls back to emoji if search fails or returns no results.
    async function autoFetchIcons() {
      const fetches = quiz.questions.map((q, qIndex) => {
        const query = q.iconSearch || q.prompt;
        return searchIconify(query).then(result => ({ qIndex, result }));
      });

      const results = await Promise.allSettled(fetches);

      for (const settled of results) {
        if (settled.status !== 'fulfilled') continue;
        const { qIndex, result } = settled.value;
        const q = quiz.questions[qIndex];

        if (!result) {
          if (!q.emoji) {
            const matches = findEmojiForWord(q.prompt);
            if (matches.length > 0) q.emoji = matches[0];
          }
          continue;
        }

        iconResults[qIndex] = result.icons;
        pickerMode[qIndex] = 'icon';

        const best = result.best;
        q.imageUrl = `https://api.iconify.design/${best.prefix}/${best.name}.svg?height=128`;
        q.imageCredit = {
          name: ICON_SET_NAMES[best.prefix] || best.prefix,
          username: best.prefix,
          profileUrl: `https://icon-sets.iconify.design/${best.prefix}/`,
        };
        q.emoji = '';
      }
    }

    // LLM-assisted icon retry: ask the LLM for better search terms for failed icons
    async function retryFailedIcons() {
      const failedIndices = quiz.questions
        .map((q, i) => (!q.imageUrl ? i : -1))
        .filter(i => i !== -1);

      if (failedIndices.length === 0) return;

      // Show spinners on failed cards and init logs
      for (const i of failedIndices) {
        const q = quiz.questions[i];
        q.iconRetrying = true;
        q.iconRetryLog = [{ text: `Initial search "${q.iconSearch || q.prompt}" ‚Äî no results`, ok: false }];
      }
      renderQuestions();

      // Retry all failed icons in parallel
      await Promise.allSettled(
        failedIndices.map(i => retryIconForQuestion(i, 3))
      );

      // Clear retry flags on any still-failed cards and re-render
      for (const i of failedIndices) {
        quiz.questions[i].iconRetrying = false;
      }
      renderQuestions();
    }

    // Sequential retry loop for one question's icon
    async function retryIconForQuestion(qIndex, maxRetries) {
      const q = quiz.questions[qIndex];
      const log = q.iconRetryLog || [];
      const triedTerms = [q.iconSearch || q.prompt];

      for (let attempt = 0; attempt < maxRetries; attempt++) {
        const newTerm = await suggestIconSearchTerm(q.prompt, triedTerms);
        if (!newTerm) {
          log.push({ text: `Retry ${attempt + 1}: LLM suggested nothing new`, skipped: true });
          continue;
        }

        triedTerms.push(newTerm);
        const result = await searchIconify(newTerm);
        if (result) {
          const best = result.best;
          iconResults[qIndex] = result.icons;
          pickerMode[qIndex] = 'icon';
          q.imageUrl = `https://api.iconify.design/${best.prefix}/${best.name}.svg?height=128`;
          q.imageCredit = {
            name: ICON_SET_NAMES[best.prefix] || best.prefix,
            username: best.prefix,
            profileUrl: `https://icon-sets.iconify.design/${best.prefix}/`,
          };
          q.emoji = '';
          q.iconRetrying = false;
          log.push({ text: `Retry ${attempt + 1}: "${newTerm}" ‚Äî found ${result.icons.length} icons`, ok: true });
          renderQuestions();
          return;
        } else {
          log.push({ text: `Retry ${attempt + 1}: "${newTerm}" ‚Äî no results`, ok: false });
        }
      }
    }

    // Ask the LLM to suggest a concrete/visual search term for a concept
    async function suggestIconSearchTerm(concept, triedTerms) {
      try {
        const prompt = `The word is "${concept}". These Iconify icon search terms found no results: ${triedTerms.join(', ')}.\nSuggest ONE different 1-3 word search term for a concrete, visual object or symbol that represents "${concept}". Reply with just the search term.`;
        const reply = await callServer(prompt, { maxTokens: 30 });
        const term = reply.trim().toLowerCase().replace(/['"]/g, '');
        if (!term || term.length > 40 || term.split(/\s+/).length > 3) return null;
        if (triedTerms.includes(term)) return null;
        return term;
      } catch {
        return null;
      }
    }

    function setPickerMode(qIndex, mode) {
      pickerMode[qIndex] = mode;
      const emojiPanel = document.getElementById(`picker-emoji-${qIndex}`);
      const iconPanel = document.getElementById(`picker-icon-${qIndex}`);
      if (emojiPanel) emojiPanel.style.display = mode === 'emoji' ? 'block' : 'none';
      if (iconPanel) iconPanel.style.display = mode === 'icon' ? 'block' : 'none';
      // Update toggle buttons
      const container = document.getElementById(`emoji-dropdown-${qIndex}`);
      if (container) {
        container.querySelectorAll('.image-picker-toggle button').forEach(btn => {
          btn.classList.toggle('active', btn.textContent.toLowerCase() === mode);
        });
      }
      // Auto-search when switching to icon mode
      if (mode === 'icon' && !iconResults[qIndex]) {
        searchIcons(qIndex);
      }
    }

    async function searchIcons(qIndex) {
      const input = document.getElementById(`icon-search-${qIndex}`);
      const query = input ? input.value.trim() : '';
      if (!query) return;

      const grid = document.getElementById(`icon-grid-${qIndex}`);
      if (grid) grid.innerHTML = '<div class="icon-empty">Searching...</div>';

      try {
        const prefixes = ICON_SET_PRIORITY.join(',');
        const resp = await fetch(`https://api.iconify.design/search?query=${encodeURIComponent(query)}&prefixes=${prefixes}&limit=32`);
        const data = await resp.json();
        if (!data.icons || data.icons.length === 0) {
          if (grid) grid.innerHTML = '<div class="icon-empty">No icons found</div>';
          return;
        }
        const icons = data.icons.map(icon => {
          const colonIdx = icon.indexOf(':');
          return { prefix: icon.substring(0, colonIdx), name: icon.substring(colonIdx + 1) };
        });
        icons.sort((a, b) => {
          const ai = ICON_SET_PRIORITY.indexOf(a.prefix);
          const bi = ICON_SET_PRIORITY.indexOf(b.prefix);
          return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);
        });
        iconResults[qIndex] = icons;
        grid.innerHTML = renderIconGrid(qIndex);
      } catch (e) {
        if (grid) grid.innerHTML = `<div class="icon-empty">Search failed: ${e.message}</div>`;
      }
    }

    function renderIconGrid(qIndex) {
      const results = iconResults[qIndex];
      if (!results || results.length === 0) {
        return '<div class="icon-empty">Search for icons above</div>';
      }
      return results.map((icon, i) => `
        <div class="icon-thumb" onclick="selectIcon(${qIndex}, ${i})" title="${icon.prefix}:${icon.name}">
          <img src="https://api.iconify.design/${icon.prefix}/${icon.name}.svg?height=64" alt="${icon.name}" loading="lazy">
        </div>
      `).join('');
    }

    function selectIcon(qIndex, iconIdx) {
      const results = iconResults[qIndex] || [];
      const icon = results[iconIdx];
      if (!icon) return;

      const q = quiz.questions[qIndex];
      q.imageUrl = `https://api.iconify.design/${icon.prefix}/${icon.name}.svg?height=128`;
      q.imageCredit = {
        name: ICON_SET_NAMES[icon.prefix] || icon.prefix,
        username: icon.prefix,
        profileUrl: `https://icon-sets.iconify.design/${icon.prefix}/`,
      };
      q.emoji = '';  // Clear emoji when icon is selected

      document.getElementById(`emoji-dropdown-${qIndex}`).classList.remove('open');
      renderQuestions();
    }

    function clearImage(qIndex) {
      const q = quiz.questions[qIndex];
      delete q.imageUrl;
      delete q.imageCredit;
      document.getElementById(`emoji-dropdown-${qIndex}`).classList.remove('open');
      renderQuestions();
    }

    // Update functions
    function updatePrompt(qIndex, value) {
      quiz.questions[qIndex].prompt = value.toLowerCase();
    }

    function updateAnswer(qIndex, value) {
      const word = value.toUpperCase();
      quiz.questions[qIndex].answer = {
        word: word,
        disguise: generateDisguise(word)
      };
      renderQuestions();
    }

    function updateDistractor(qIndex, dIndex, value) {
      const word = value.toUpperCase();
      quiz.questions[qIndex].distractors[dIndex].word = word;
      quiz.questions[qIndex].distractors[dIndex].disguise = generateDisguise(word);
      renderQuestions();
    }

    function updateAnswerDisguise(qIndex, value) {
      quiz.questions[qIndex].answer.disguise = value.toLowerCase();
    }

    function updateDistractorDisguise(qIndex, dIndex, value) {
      quiz.questions[qIndex].distractors[dIndex].disguise = value.toLowerCase();
    }

    function cycleType(qIndex, dIndex) {
      const types = ['wrong-letters', 'non-synonym', 'phonetic-trap'];
      const d = quiz.questions[qIndex].distractors[dIndex];
      const currentIdx = types.indexOf(d.type);
      d.type = types[(currentIdx + 1) % types.length];
      renderQuestions();
    }

    // Reshuffle functions
    async function reshufflePrompt(qIndex) {
      const q = quiz.questions[qIndex];
      q.rejectedPrompts.push(q.prompt);

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentModel === 'rules') {
          q.prompt = `newprompt${qIndex + 1}`;
        } else {
          const prompt = `Give me ONE different word related to "${quiz.theme}" that could be used as a quiz prompt.
Avoid these words: ${q.rejectedPrompts.join(', ')}
Return ONLY the single word, nothing else.`;
          const response = await callServer(prompt);
          q.prompt = response.trim().toLowerCase().replace(/[^a-z]/g, '');
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ';
    }

    async function reshuffleAnswer(qIndex) {
      const q = quiz.questions[qIndex];
      q.rejectedAnswers.push(q.answer.word);

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentModel === 'rules') {
          q.answer = { word: `NEWANS${qIndex + 1}`, disguise: generateDisguise(`NEWANS${qIndex + 1}`) };
        } else {
          const prompt = `Give me ONE synonym for "${q.prompt}".
Avoid these words: ${q.rejectedAnswers.join(', ')}
Return ONLY the single word in UPPERCASE, nothing else.`;
          const response = await callServer(prompt);
          const word = response.trim().toUpperCase().replace(/[^A-Z]/g, '');
          q.answer = { word, disguise: generateDisguise(word) };
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ';
    }

    async function reshuffleDistractor(qIndex, dIndex) {
      const q = quiz.questions[qIndex];
      const d = q.distractors[dIndex];
      q.rejectedDistractors.push(d.word);

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentModel === 'rules') {
          d.word = `NEWDIST${qIndex}${dIndex}`;
          d.disguise = generateDisguise(d.word);
        } else {
          const existingWords = [q.answer.word, q.prompt.toUpperCase(), ...q.distractors.map(x => x.word), ...q.rejectedDistractors];
          const prompt = `Give me ONE distractor word for a synonym quiz.
The prompt is "${q.prompt}" and the answer is "${q.answer.word}".
The distractor type should be: ${d.type === 'phonetic-trap' ? 'non-synonym' : d.type}
- wrong-letters: consonant pattern slightly off from a plausible word
- non-synonym: valid word in same category but not a synonym

Avoid these words: ${existingWords.join(', ')}
Return ONLY the single word in UPPERCASE, nothing else.`;
          const response = await callServer(prompt);
          let newWord = response.trim().toUpperCase().replace(/[^A-Z]/g, '');
          // Validate it's not the answer or prompt
          if (newWord === q.answer.word || newWord === q.prompt.toUpperCase()) {
            throw new Error('AI suggested the answer/prompt. Try again.');
          }
          d.word = newWord;
          d.disguise = generateDisguise(d.word);
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ';
    }

    async function reshuffleAllDistractors(qIndex) {
      const q = quiz.questions[qIndex];
      q.rejectedDistractors.push(...q.distractors.map(d => d.word));

      const btn = event.target;
      btn.disabled = true;
      btn.textContent = '...';

      try {
        if (currentModel === 'rules') {
          q.distractors = [
            { word: `NEW${qIndex}A`, disguise: generateDisguise(`NEW${qIndex}A`), type: 'wrong-letters' },
            { word: `NEW${qIndex}B`, disguise: generateDisguise(`NEW${qIndex}B`), type: 'non-synonym' },
            { word: `NEW${qIndex}C`, disguise: generateDisguise(`NEW${qIndex}C`), type: 'phonetic-trap' },
          ];
        } else {
          const prompt = `Generate 3 distractor words for a synonym quiz.
The prompt is "${q.prompt}" and the answer is "${q.answer.word}".

Provide exactly 3 distractors with types (use ONLY these two types):
1. wrong-letters: consonant pattern slightly off from a plausible word
2. non-synonym: valid word in same category but not a synonym
Mix of types is fine. Use whichever fits best for each distractor.

Avoid these words: ${[q.answer.word, q.prompt.toUpperCase(), ...q.rejectedDistractors].join(', ')}

Format as JSON array: [{"word": "WORD", "type": "type"}]
Return ONLY the JSON array.`;
          const response = await callServer(prompt);
          const jsonMatch = response.match(/\[[\s\S]*\]/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            const forbidden = [q.answer.word, q.prompt.toUpperCase()];
            q.distractors = parsed.slice(0, 3)
              .map(d => ({
                word: (d.word || '').toUpperCase(),
                disguise: generateDisguise(d.word || ''),
                type: d.type || 'non-synonym'
              }))
              .filter(d => !forbidden.includes(d.word));
            // Pad if some were filtered
            while (q.distractors.length < 3) {
              q.distractors.push({ word: 'EDIT_ME', disguise: 'dtm', type: 'non-synonym' });
            }
          }
        }
        renderQuestions();
      } catch (e) {
        alert('Reshuffle failed: ' + e.message);
      }

      btn.disabled = false;
      btn.textContent = 'üîÑ All';
    }

    // Build output JSON
    function buildQuizJSON() {
      const pubDate = document.getElementById('pubDate').value;
      return {
        theme: quiz.theme,
        publicationDate: pubDate,
        questions: quiz.questions.map(q => {
          const out = {
            prompt: q.prompt,
            emoji: q.emoji || '',
            answer: q.answer.word,
            answerDisguise: q.answer.disguise,
            distractors: q.distractors.map(d => ({
              word: d.word,
              disguise: d.disguise,
              type: d.type
            })),
            ...(q.difficulty && { difficulty: q.difficulty }),
            ...(q.correctOption && { correctOption: q.correctOption }),
          };
          if (q.imageUrl) {
            out.imageUrl = q.imageUrl;
            out.imageCredit = q.imageCredit;
          }
          return out;
        })
      };
    }

    // Export to clipboard
    function exportQuiz() {
      const output = buildQuizJSON();
      const json = JSON.stringify(output, null, 2);
      navigator.clipboard.writeText(json).then(() => {
        alert('Quiz JSON copied to clipboard!');
      }).catch(() => {
        prompt('Copy this JSON:', json);
      });
    }

    // Save to filesystem
    async function saveQuiz() {
      const pubDate = document.getElementById('pubDate').value;
      if (!pubDate) {
        alert('Please set a publication date');
        return;
      }

      const output = buildQuizJSON();

      try {
        const response = await fetch('/api/save-puzzle', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(output)
        });

        const result = await response.json();
        if (response.ok) {
          alert(`Saved to ${result.filename}`);
          clearQuiz(true);
          await initPubDate();
        } else {
          alert('Save failed: ' + result.error);
        }
      } catch (e) {
        alert('Save failed: ' + e.message);
      }
    }

    function clearQuiz(skipConfirm = false) {
      if (!skipConfirm && !confirm('Clear all questions?')) return;
      {
        quiz = { theme: '', questions: [] };
        document.getElementById('themeInput').value = '';
        document.getElementById('questionsContainer').innerHTML = `
          <div class="empty-state">
            <h3>No quiz generated yet</h3>
            <p>Enter a theme above and click "Generate 6 Questions"</p>
          </div>
        `;
        document.getElementById('exportSection').classList.add('hidden');
      }
    }

    // API call
    async function callServer(prompt, { maxTokens } = {}) {
      const body = { model: currentModel, prompt };
      if (maxTokens) body.max_tokens = maxTokens;

      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });

      const data = await response.json();
      if (!response.ok || data.error) {
        throw new Error(data.error || 'Server error');
      }
      return data.content;
    }

    // Initialize
    loadEmojiData();
  </script>
</body>
</html>
