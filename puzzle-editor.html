<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>cnmn Puzzle Editor</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(165deg, #fdfbf7 0%, #f5e6d3 50%, #ecdbc8 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    h1 {
      color: #6b3410;
      margin-bottom: 10px;
      font-size: 28px;
      letter-spacing: 2px;
    }

    .subtitle {
      color: #8b6340;
      margin-bottom: 30px;
      font-size: 14px;
    }

    .panel {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 4px 20px rgba(107, 52, 16, 0.1);
      margin-bottom: 20px;
    }

    .panel h2 {
      color: #6b3410;
      margin-bottom: 16px;
      font-size: 18px;
    }

    .form-row {
      display: flex;
      gap: 12px;
      align-items: end;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .form-group {
      flex: 1;
      min-width: 150px;
    }

    label {
      display: block;
      margin-bottom: 6px;
      color: #6b3410;
      font-weight: 600;
      font-size: 13px;
    }

    input[type="text"], select {
      width: 100%;
      padding: 10px 12px;
      border: 2px solid #c4a574;
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    input:focus, select:focus {
      outline: none;
      border-color: #6b3410;
    }

    button {
      background: #6b3410;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    button:hover {
      background: #8b4513;
    }

    button:disabled {
      background: #c4a574;
      cursor: not-allowed;
    }

    button.small {
      padding: 6px 10px;
      font-size: 12px;
    }

    button.secondary {
      background: #8b6340;
    }

    button.export {
      background: #2e7d32;
    }

    button.export:hover {
      background: #388e3c;
    }

    .hint {
      font-size: 12px;
      color: #8b6340;
      margin-top: 4px;
      font-style: italic;
    }

    /* Question cards */
    .questions-grid {
      display: grid;
      gap: 16px;
    }

    .question-card {
      background: white;
      border: 2px solid #ecdbc8;
      border-radius: 12px;
      padding: 16px;
    }

    .question-card.dirty {
      border-color: #e6a030;
    }

    .question-card h3 {
      color: #6b3410;
      font-size: 14px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .question-card h3 .num {
      background: #6b3410;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .field-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }

    .field-row label {
      width: 70px;
      margin: 0;
      font-size: 12px;
      flex-shrink: 0;
    }

    .field-row input {
      flex: 1;
      padding: 6px 10px;
      font-size: 13px;
    }

    .disguise-input {
      font-family: 'Courier New', monospace;
      background: #2d2d2d;
      color: #f8f8f2;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      width: 70px;
      text-align: center;
      border: 2px solid #2d2d2d;
    }

    .disguise-input:focus {
      border-color: #6b3410;
      outline: none;
    }

    @keyframes disguise-flash {
      0% { background: #2d2d2d; }
      30% { background: #4a7c50; border-color: #2e7d32; }
      100% { background: #2d2d2d; }
    }

    .disguise-input.flash {
      animation: disguise-flash 0.4s ease;
    }

    .type-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 10px;
      background: #ecdbc8;
      color: #6b3410;
      white-space: nowrap;
      cursor: pointer;
    }

    .type-badge:hover {
      opacity: 0.8;
    }

    .type-badge.wrong-letters { background: #ffcdd2; color: #c62828; }
    .type-badge.non-synonym { background: #fff3e0; color: #e65100; }
    .type-badge.phonetic-trap { background: #e3f2fd; color: #1565c0; }

    .distractors-section {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid #ecdbc8;
    }

    .distractors-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .distractors-header label {
      font-size: 12px;
      margin: 0;
    }

    .difficulty-badge {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .difficulty-badge.easy { background: #e8f5e9; color: #2e7d32; }
    .difficulty-badge.medium { background: #fff3e0; color: #e65100; }
    .difficulty-badge.hard { background: #ffebee; color: #c62828; }

    .hidden {
      display: none !important;
    }

    .export-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid #ecdbc8;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #8b6340;
    }

    .empty-state h3 {
      color: #6b3410;
      margin-bottom: 8px;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #8b6340;
    }

    .spinner {
      border: 3px solid #ecdbc8;
      border-top: 3px solid #6b3410;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Dirty indicator */
    .dirty-indicator {
      display: inline-block;
      background: #e65100;
      color: white;
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 10px;
      margin-left: 8px;
      font-weight: 600;
    }

    /* Move buttons */
    .move-buttons {
      display: flex;
      gap: 4px;
      margin-left: auto;
    }

    .move-buttons button {
      padding: 2px 8px;
      font-size: 12px;
      background: #ecdbc8;
      color: #6b3410;
    }

    .move-buttons button:hover {
      background: #c4a574;
    }

    .card-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
    }

    .card-header .num {
      background: #6b3410;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      flex-shrink: 0;
    }

    /* Difficulty select within card */
    .difficulty-select {
      padding: 4px 8px;
      font-size: 12px;
      border: 2px solid #c4a574;
      border-radius: 6px;
      background: white;
    }

    /* Toast notification */
    .toast {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #2e7d32;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 1000;
      transition: opacity 0.3s;
    }

    .toast.error {
      background: #c62828;
    }

    /* Emoji picker */
    .emoji-picker-container {
      position: relative;
      display: inline-block;
    }

    .emoji-btn {
      width: 40px;
      height: 36px;
      font-size: 20px;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      border: 2px solid #c4a574;
      color: #6b3410;
    }

    .emoji-btn:hover {
      background: #f5e6d3;
    }

    .emoji-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      z-index: 100;
      background: white;
      border: 2px solid #c4a574;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
      width: 340px;
      flex-direction: column;
    }

    .emoji-dropdown.open {
      display: flex;
    }

    .emoji-search {
      padding: 10px;
      border-bottom: 1px solid #ecdbc8;
    }

    .emoji-search input {
      width: 100%;
      padding: 8px 12px;
      border: 2px solid #ecdbc8;
      border-radius: 6px;
      font-size: 13px;
      outline: none;
    }

    .emoji-search input:focus {
      border-color: #c4a574;
    }

    .emoji-tabs {
      display: flex;
      border-bottom: 1px solid #ecdbc8;
      padding: 0 6px;
      overflow-x: auto;
      scrollbar-width: none;
    }

    .emoji-tabs::-webkit-scrollbar {
      display: none;
    }

    .emoji-tab {
      padding: 8px 6px;
      font-size: 18px;
      background: none;
      border: none;
      border-bottom: 2px solid transparent;
      cursor: pointer;
      opacity: 0.5;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .emoji-tab:hover {
      opacity: 0.8;
    }

    .emoji-tab.active {
      opacity: 1;
      border-bottom-color: #6b3410;
    }

    .emoji-grid-container {
      height: 200px;
      overflow-y: auto;
      padding: 8px;
    }

    .emoji-section-label {
      font-size: 11px;
      color: #8b6340;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 4px 4px 8px;
      font-weight: 600;
    }

    .emoji-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 2px;
    }

    .emoji-option {
      width: 34px;
      height: 34px;
      font-size: 22px;
      background: none;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: all 0.15s;
    }

    .emoji-option:hover {
      background: #f5e6d3;
      transform: scale(1.15);
    }

    .emoji-option.suggested {
      box-shadow: 0 0 0 2px #c4a574;
      border-radius: 6px;
    }

    .emoji-footer {
      display: flex;
      justify-content: space-between;
      padding: 8px 10px;
      border-top: 1px solid #ecdbc8;
      background: #faf7f2;
      border-radius: 0 0 10px 10px;
    }

    .emoji-clear {
      background: #ecdbc8;
      color: #6b3410;
      font-size: 11px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }

    .emoji-clear:hover {
      background: #dcc9a8;
    }

    .emoji-no-results {
      text-align: center;
      padding: 30px;
      color: #8b6340;
      font-size: 13px;
    }

    .emoji-direct-input {
      width: 90px;
      padding: 5px 8px;
      border: 2px solid #ecdbc8;
      border-radius: 4px;
      font-size: 16px;
      text-align: center;
    }

    .emoji-direct-input:focus {
      border-color: #c4a574;
      outline: none;
    }

    .emoji-ai-suggest {
      background: #6b3410;
      color: white;
      font-size: 11px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
    }

    .emoji-ai-suggest:hover:not(:disabled) {
      background: #8b4513;
    }

    .emoji-ai-suggest:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Image picker toggle (Emoji/Icon tabs) */
    .image-picker-toggle {
      display: flex;
      gap: 0;
      margin-bottom: 4px;
    }

    .image-picker-toggle button {
      flex: 1;
      padding: 6px 10px;
      font-size: 11px;
      font-weight: 600;
      border: 2px solid #c4a574;
      background: #faf7f2;
      color: #8b6340;
      cursor: pointer;
      transition: all 0.15s;
    }

    .image-picker-toggle button:first-child {
      border-radius: 6px 0 0 6px;
    }

    .image-picker-toggle button:last-child {
      border-radius: 0 6px 6px 0;
    }

    .image-picker-toggle button.active {
      background: #6b3410;
      color: white;
      border-color: #6b3410;
    }

    .image-picker-toggle button:hover:not(.active) {
      background: #f0e4d3;
    }

    /* Icon search row */
    .icon-search-row {
      display: flex;
      gap: 6px;
      padding: 10px;
      border-bottom: 1px solid #ecdbc8;
    }

    .icon-search-row input {
      flex: 1;
      padding: 8px 12px;
      border: 2px solid #ecdbc8;
      border-radius: 6px;
      font-size: 13px;
      outline: none;
    }

    .icon-search-row input:focus {
      border-color: #c4a574;
    }

    .icon-search-row button {
      padding: 8px 14px;
      font-size: 12px;
    }

    /* Icon grid */
    .icon-grid {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      padding: 8px;
      height: 240px;
      overflow-y: auto;
    }

    .icon-thumb {
      cursor: pointer;
      border-radius: 6px;
      aspect-ratio: 1;
      border: 2px solid transparent;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4px;
      background: #faf7f2;
    }

    .icon-thumb:hover {
      border-color: #6b3410;
      transform: scale(1.08);
      background: #f0e6d6;
    }

    .icon-thumb img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      display: block;
    }

    .icon-empty {
      text-align: center;
      padding: 40px 20px;
      color: #8b6340;
      font-size: 13px;
      grid-column: 1 / -1;
    }

    /* Icon footer */
    .icon-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border-top: 1px solid #ecdbc8;
      background: #faf7f2;
      border-radius: 0 0 10px 10px;
    }

    .icon-footer span {
      font-size: 10px;
      color: #8b6340;
    }

    /* Image preview (shows selected icon in place of emoji button) */
    .image-preview {
      width: 40px;
      height: 36px;
      border-radius: 4px;
      overflow: hidden;
      border: 2px solid #c4a574;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      cursor: pointer;
    }

    .image-preview img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    /* Generate panel */
    .generate-panel {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 2px solid #ecdbc8;
    }

    .generate-panel h2 {
      margin-bottom: 12px;
    }

    input[type="number"], input[type="date"] {
      width: 100%;
      padding: 10px 12px;
      border: 2px solid #c4a574;
      border-radius: 6px;
      font-size: 14px;
      font-family: inherit;
      transition: border-color 0.2s;
    }

    input[type="number"]:focus, input[type="date"]:focus {
      outline: none;
      border-color: #6b3410;
    }

    .generate-actions {
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    button.generate {
      background: #1565c0;
    }

    button.generate:hover:not(:disabled) {
      background: #1976d2;
    }

    button.cancel {
      background: #c62828;
    }

    button.cancel:hover {
      background: #d32f2f;
    }

    .generation-progress {
      padding: 20px 0;
    }

    .progress-puzzle-count {
      background: #6b3410;
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      margin-bottom: 16px;
      text-align: center;
    }

    .progress-stage {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 16px;
      border-radius: 8px;
      margin-bottom: 6px;
      font-size: 14px;
      color: #8b6340;
      background: #faf7f2;
      transition: all 0.3s;
    }

    .progress-stage.active {
      background: #fff3e0;
      color: #6b3410;
      font-weight: 600;
    }

    .progress-stage.completed {
      background: #e8f5e9;
      color: #2e7d32;
    }

    .progress-stage.error {
      background: #ffebee;
      color: #c62828;
    }

    .stage-icon {
      width: 24px;
      text-align: center;
      flex-shrink: 0;
    }

    .progress-spinner-inline {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #ecdbc8;
      border-top: 2px solid #6b3410;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    .progress-detail {
      font-size: 12px;
      color: #8b6340;
      margin-left: 36px;
      margin-top: 2px;
      margin-bottom: 4px;
    }

    #genThemeInput.ideating::placeholder {
      font-style: italic;
    }

    /* Generation summary (persistent collapsed panel) */
    .gen-summary { margin-bottom: 16px; }

    .gen-summary-bar {
      cursor: pointer;
      padding: 12px 16px;
      border-radius: 8px;
      background: #e8f5e9;
      color: #2e7d32;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .gen-summary-bar:hover { background: #c8e6c9; }

    .gen-summary-body { display: none; padding: 12px 0; }
    .gen-summary.expanded .gen-summary-body { display: block; }
    .gen-summary.expanded .gen-summary-arrow { transform: rotate(180deg); }

    .gen-summary-arrow {
      transition: transform 0.2s;
      font-size: 12px;
    }

    .stage-transcript {
      margin-left: 36px;
      font-size: 12px;
      color: #6b3410;
      padding: 4px 0 8px;
      font-family: 'Courier New', monospace;
      line-height: 1.6;
    }

    .stage-transcript .pick-correct { color: #2e7d32; }
    .stage-transcript .pick-wrong { color: #c62828; font-weight: 600; }

    @media (max-width: 600px) {
      .form-row { flex-direction: column; gap: 8px; }
      .field-row { flex-wrap: wrap; }
      .field-row label { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>cnmn Puzzle Editor</h1>
    <p class="subtitle">View and edit existing puzzles</p>

    <!-- Header panel: date picker + metadata -->
    <div class="panel" id="headerPanel">
      <div class="form-row">
        <div class="form-group">
          <label for="dateSelect">Puzzle Date</label>
          <select id="dateSelect" onchange="onDateChange(this.value)">
            <option value="">Loading...</option>
          </select>
        </div>
        <div class="form-group">
          <label for="themeInput">Theme</label>
          <input type="text" id="themeInput" placeholder="Theme" oninput="updateMeta('theme', this.value)">
        </div>
        <div class="form-group">
          <label for="pubDateInput">Publication Date</label>
          <input type="text" id="pubDateInput" placeholder="YYYY-MM-DD" oninput="updateMeta('publicationDate', this.value)">
        </div>
      </div>
      <div class="export-section">
        <button onclick="savePuzzle()">Save</button>
        <button class="export" onclick="exportJSON()">Copy JSON</button>
        <button class="secondary" onclick="regenAllDisguises()">Re-derive All Disguises</button>
        <button class="secondary" onclick="toggleGeneratePanel()" id="generateNewBtn">Generate New</button>
        <span id="dirtyIndicator" class="dirty-indicator hidden">Unsaved changes</span>
      </div>
      <div id="generatePanel" class="generate-panel hidden">
        <h2>Generate New Puzzles</h2>
        <div class="form-row">
          <div class="form-group">
            <label for="genThemeInput">Theme</label>
            <input type="text" id="genThemeInput" placeholder="e.g. Ocean Animals" oninput="updateGenButtonState()">
          </div>
          <div class="form-group" style="max-width: 100px">
            <label for="genCountInput">Count</label>
            <input type="number" id="genCountInput" min="1" max="10" value="1" oninput="updateGenButtonState()">
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label for="genDateInput">Starting Date</label>
            <input type="date" id="genDateInput" oninput="updateGenButtonState()">
          </div>
          <div class="form-group">
            <label for="genModelSelect">Model</label>
            <select id="genModelSelect" onchange="updateGenButtonState()">
              <option value="">Loading models...</option>
            </select>
          </div>
        </div>
        <div class="generate-actions">
          <button class="generate" id="genStartBtn" onclick="startGeneration()" disabled>Generate</button>
          <button class="cancel hidden" id="genCancelBtn" onclick="cancelGeneration()">Cancel</button>
        </div>
      </div>
    </div>

    <!-- Questions -->
    <div id="questionsContainer">
      <div class="empty-state">
        <h3>No puzzle loaded</h3>
        <p>Select a date above to load a puzzle.</p>
      </div>
    </div>
  </div>

  <script>
    // â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let puzzle = null;
    let dirty = false;
    let originalJson = '';
    let generationTranscript = null;

    // Emoji picker state
    const emojiCategories = {
      'Smileys': {
        icon: 'ðŸ˜€',
        emojis: ['ðŸ˜€','ðŸ˜ƒ','ðŸ˜„','ðŸ˜','ðŸ˜…','ðŸ˜‚','ðŸ¤£','ðŸ˜Š','ðŸ˜‡','ðŸ™‚','ðŸ˜‰','ðŸ˜Œ','ðŸ˜','ðŸ¥°','ðŸ˜˜','ðŸ˜‹','ðŸ˜›','ðŸ˜œ','ðŸ¤ª','ðŸ˜','ðŸ¤‘','ðŸ¤—','ðŸ¤­','ðŸ¤«','ðŸ¤”','ðŸ¤','ðŸ¤¨','ðŸ˜','ðŸ˜‘','ðŸ˜¶','ðŸ˜','ðŸ˜’','ðŸ™„','ðŸ˜¬','ðŸ˜®â€ðŸ’¨','ðŸ¤¥','ðŸ˜Œ','ðŸ˜”','ðŸ˜ª','ðŸ¤¤','ðŸ˜´','ðŸ˜·','ðŸ¤’','ðŸ¤•','ðŸ¤¢','ðŸ¤®','ðŸ¤§','ðŸ¥µ','ðŸ¥¶','ðŸ¥´','ðŸ˜µ','ðŸ¤¯','ðŸ¤ ','ðŸ¥³','ðŸ¥¸','ðŸ˜Ž','ðŸ¤“','ðŸ§','ðŸ˜•','ðŸ˜Ÿ','ðŸ™','â˜¹ï¸','ðŸ˜®','ðŸ˜¯','ðŸ˜²','ðŸ˜³','ðŸ¥º','ðŸ˜¦','ðŸ˜§','ðŸ˜¨','ðŸ˜°','ðŸ˜¥','ðŸ˜¢','ðŸ˜­','ðŸ˜±','ðŸ˜–','ðŸ˜£','ðŸ˜ž','ðŸ˜“','ðŸ˜©','ðŸ˜«','ðŸ¥±','ðŸ˜¤','ðŸ˜¡','ðŸ˜ ','ðŸ¤¬','ðŸ˜ˆ','ðŸ‘¿','ðŸ’€','â˜ ï¸','ðŸ’©','ðŸ¤¡','ðŸ‘¹','ðŸ‘º','ðŸ‘»','ðŸ‘½','ðŸ‘¾','ðŸ¤–']
      },
      'People': {
        icon: 'ðŸ‘‹',
        emojis: ['ðŸ‘‹','ðŸ¤š','ðŸ–ï¸','âœ‹','ðŸ––','ðŸ‘Œ','ðŸ¤Œ','ðŸ¤','âœŒï¸','ðŸ¤ž','ðŸ¤Ÿ','ðŸ¤˜','ðŸ¤™','ðŸ‘ˆ','ðŸ‘‰','ðŸ‘†','ðŸ–•','ðŸ‘‡','â˜ï¸','ðŸ‘','ðŸ‘Ž','âœŠ','ðŸ‘Š','ðŸ¤›','ðŸ¤œ','ðŸ‘','ðŸ™Œ','ðŸ‘','ðŸ¤²','ðŸ¤','ðŸ™','âœï¸','ðŸ’…','ðŸ¤³','ðŸ’ª','ðŸ¦¾','ðŸ¦¿','ðŸ¦µ','ðŸ¦¶','ðŸ‘‚','ðŸ¦»','ðŸ‘ƒ','ðŸ§ ','ðŸ«€','ðŸ«','ðŸ¦·','ðŸ¦´','ðŸ‘€','ðŸ‘ï¸','ðŸ‘…','ðŸ‘„','ðŸ‘¶','ðŸ§’','ðŸ‘¦','ðŸ‘§','ðŸ§‘','ðŸ‘±','ðŸ‘¨','ðŸ§”','ðŸ‘©','ðŸ§“','ðŸ‘´','ðŸ‘µ','ðŸ™','ðŸ™Ž','ðŸ™…','ðŸ™†','ðŸ’','ðŸ™‹','ðŸ§','ðŸ™‡','ðŸ¤¦','ðŸ¤·','ðŸ‘®','ðŸ•µï¸','ðŸ’‚','ðŸ¥·','ðŸ‘·','ðŸ¤´','ðŸ‘¸','ðŸ‘³','ðŸ‘²','ðŸ§•','ðŸ¤µ','ðŸ‘°','ðŸ¤°','ðŸ«ƒ','ðŸ«„','ðŸ¤±','ðŸ‘¼','ðŸŽ…','ðŸ¤¶','ðŸ¦¸','ðŸ¦¹','ðŸ§™','ðŸ§š','ðŸ§›','ðŸ§œ','ðŸ§','ðŸ§ž','ðŸ§Ÿ','ðŸ’†','ðŸ’‡','ðŸš¶','ðŸ§','ðŸ§Ž','ðŸƒ','ðŸ’ƒ','ðŸ•º','ðŸ•´ï¸','ðŸ‘¯','ðŸ§–','ðŸ§—','ðŸ¤¸','ðŸŒï¸','ðŸ‡','â›·ï¸','ðŸ‚','ðŸ‹ï¸','ðŸ¤¼','ðŸ¤½','ðŸ¤¾','ðŸ¤º','â›¹ï¸','ðŸŠ','ðŸš£','ðŸ§˜','ðŸ›€','ðŸ›Œ']
      },
      'Animals': {
        icon: 'ðŸ¾',
        emojis: ['ðŸ¶','ðŸ•','ðŸ¦®','ðŸ•â€ðŸ¦º','ðŸ©','ðŸº','ðŸ¦Š','ðŸ¦','ðŸ±','ðŸˆ','ðŸˆâ€â¬›','ðŸ¦','ðŸ¯','ðŸ…','ðŸ†','ðŸ´','ðŸŽ','ðŸ¦„','ðŸ¦“','ðŸ¦Œ','ðŸ¦¬','ðŸ®','ðŸ‚','ðŸƒ','ðŸ„','ðŸ·','ðŸ–','ðŸ—','ðŸ½','ðŸ','ðŸ‘','ðŸ','ðŸª','ðŸ«','ðŸ¦™','ðŸ¦’','ðŸ˜','ðŸ¦£','ðŸ¦','ðŸ¦›','ðŸ­','ðŸ','ðŸ€','ðŸ¹','ðŸ°','ðŸ‡','ðŸ¿ï¸','ðŸ¦«','ðŸ¦”','ðŸ¦‡','ðŸ»','ðŸ»â€â„ï¸','ðŸ¨','ðŸ¼','ðŸ¦¥','ðŸ¦¦','ðŸ¦¨','ðŸ¦˜','ðŸ¦¡','ðŸ¾','ðŸ¦ƒ','ðŸ”','ðŸ“','ðŸ£','ðŸ¤','ðŸ¥','ðŸ¦','ðŸ§','ðŸ•Šï¸','ðŸ¦…','ðŸ¦†','ðŸ¦¢','ðŸ¦‰','ðŸ¦¤','ðŸª¶','ðŸ¦©','ðŸ¦š','ðŸ¦œ','ðŸ¸','ðŸŠ','ðŸ¢','ðŸ¦Ž','ðŸ','ðŸ²','ðŸ‰','ðŸ¦•','ðŸ¦–','ðŸ³','ðŸ‹','ðŸ¬','ðŸ¦­','ðŸŸ','ðŸ ','ðŸ¡','ðŸ¦ˆ','ðŸ™','ðŸš','ðŸŒ','ðŸ¦‹','ðŸ›','ðŸœ','ðŸ','ðŸª²','ðŸž','ðŸ¦—','ðŸª³','ðŸ•·ï¸','ðŸ•¸ï¸','ðŸ¦‚','ðŸ¦Ÿ','ðŸª°','ðŸª±','ðŸ¦ ']
      },
      'Nature': {
        icon: 'ðŸŒ¿',
        emojis: ['ðŸ’','ðŸŒ¸','ðŸ’®','ðŸµï¸','ðŸŒ¹','ðŸ¥€','ðŸŒº','ðŸŒ»','ðŸŒ¼','ðŸŒ·','ðŸŒ±','ðŸª´','ðŸŒ²','ðŸŒ³','ðŸŒ´','ðŸŒµ','ðŸŒ¾','ðŸŒ¿','â˜˜ï¸','ðŸ€','ðŸ','ðŸ‚','ðŸƒ','ðŸ‡','ðŸˆ','ðŸ‰','ðŸŠ','ðŸ‹','ðŸŒ','ðŸ','ðŸ¥­','ðŸŽ','ðŸ','ðŸ','ðŸ‘','ðŸ’','ðŸ“','ðŸ«','ðŸ¥','ðŸ…','ðŸ«’','ðŸ¥¥','ðŸ¥‘','ðŸ†','ðŸ¥”','ðŸ¥•','ðŸŒ½','ðŸŒ¶ï¸','ðŸ«‘','ðŸ¥’','ðŸ¥¬','ðŸ¥¦','ðŸ§„','ðŸ§…','ðŸ„','ðŸ¥œ','ðŸŒ°','ðŸž','ðŸ¥','ðŸ¥–','ðŸ«“','ðŸ¥¨','ðŸ¥¯','ðŸ¥ž','ðŸ§‡','ðŸ§€','ðŸ–','ðŸ—','ðŸ¥©','ðŸ¥“','ðŸ”','ðŸŸ','ðŸ•','ðŸŒ­','ðŸ¥ª','ðŸŒ®','ðŸŒ¯','ðŸ«”','ðŸ¥™','ðŸ§†','ðŸ¥š','ðŸ³','ðŸ¥˜','ðŸ²','ðŸ«•','ðŸ¥£','ðŸ¥—','ðŸ¿','ðŸ§ˆ','ðŸ§‚','ðŸ¥«','ðŸ±','ðŸ˜','ðŸ™','ðŸš','ðŸ›','ðŸœ','ðŸ','ðŸ ','ðŸ¢','ðŸ£','ðŸ¤','ðŸ¥','ðŸ¥®','ðŸ¡','ðŸ¥Ÿ','ðŸ¥ ','ðŸ¥¡','ðŸ¦€','ðŸ¦ž','ðŸ¦','ðŸ¦‘','ðŸ¦ª','ðŸ¦','ðŸ§','ðŸ¨','ðŸ©','ðŸª','ðŸŽ‚','ðŸ°','ðŸ§','ðŸ¥§','ðŸ«','ðŸ¬','ðŸ­','ðŸ®','ðŸ¯','ðŸ¼','ðŸ¥›','â˜•','ðŸ«–','ðŸµ','ðŸ¶','ðŸ¾','ðŸ·','ðŸ¸','ðŸ¹','ðŸº','ðŸ»','ðŸ¥‚','ðŸ¥ƒ','ðŸ¥¤','ðŸ§‹','ðŸ§ƒ','ðŸ§‰','ðŸ§Š']
      },
      'Travel': {
        icon: 'âœˆï¸',
        emojis: ['ðŸš—','ðŸš•','ðŸš™','ðŸšŒ','ðŸšŽ','ðŸŽï¸','ðŸš“','ðŸš‘','ðŸš’','ðŸš','ðŸ›»','ðŸšš','ðŸš›','ðŸšœ','ðŸï¸','ðŸ›µ','ðŸš²','ðŸ›´','ðŸ›¹','ðŸ›¼','ðŸš','ðŸ›£ï¸','ðŸ›¤ï¸','ðŸ›¢ï¸','â›½','ðŸš¨','ðŸš¥','ðŸš¦','ðŸ›‘','ðŸš§','âš“','â›µ','ðŸ›¶','ðŸš¤','ðŸ›³ï¸','â›´ï¸','ðŸ›¥ï¸','ðŸš¢','âœˆï¸','ðŸ›©ï¸','ðŸ›«','ðŸ›¬','ðŸª‚','ðŸ’º','ðŸš','ðŸšŸ','ðŸš ','ðŸš¡','ðŸ›°ï¸','ðŸš€','ðŸ›¸','ðŸ›Žï¸','ðŸ§³','âŒ›','â³','âŒš','â°','â±ï¸','â²ï¸','ðŸ•°ï¸','ðŸŒ¡ï¸','ðŸ—ºï¸','ðŸ§­','ðŸ”ï¸','â›°ï¸','ðŸŒ‹','ðŸ—»','ðŸ•ï¸','ðŸ–ï¸','ðŸœï¸','ðŸï¸','ðŸžï¸','ðŸŸï¸','ðŸ›ï¸','ðŸ—ï¸','ðŸ§±','ðŸª¨','ðŸªµ','ðŸ›–','ðŸ˜ï¸','ðŸšï¸','ðŸ ','ðŸ¡','ðŸ¢','ðŸ£','ðŸ¤','ðŸ¥','ðŸ¦','ðŸ¨','ðŸ©','ðŸª','ðŸ«','ðŸ¬','ðŸ­','ðŸ¯','ðŸ°','ðŸ’’','ðŸ—¼','ðŸ—½','â›ª','ðŸ•Œ','ðŸ›•','ðŸ•','â›©ï¸','ðŸ•‹','â›²','â›º','ðŸŒ','ðŸŒƒ','ðŸ™ï¸','ðŸŒ„','ðŸŒ…','ðŸŒ†','ðŸŒ‡','ðŸŒ‰','ðŸŽ ','ðŸŽ¡','ðŸŽ¢','ðŸ’ˆ','ðŸŽª']
      },
      'Activities': {
        icon: 'âš½',
        emojis: ['âš½','ðŸ€','ðŸˆ','âš¾','ðŸ¥Ž','ðŸŽ¾','ðŸ','ðŸ‰','ðŸ¥','ðŸŽ±','ðŸª€','ðŸ“','ðŸ¸','ðŸ’','ðŸ‘','ðŸ¥','ðŸ','ðŸªƒ','ðŸ¥…','â›³','ðŸª','ðŸ¹','ðŸŽ£','ðŸ¤¿','ðŸ¥Š','ðŸ¥‹','ðŸŽ½','ðŸ›·','ðŸŽ¿','â›·ï¸','ðŸ‚','ðŸª‚','ðŸ‹ï¸','ðŸ¤¼','ðŸ¤¸','ðŸ¤º','â›¹ï¸','ðŸ¤¾','ðŸŒï¸','ðŸ‡','â›¸ï¸','ðŸŠ','ðŸš´','ðŸšµ','ðŸ§—','ðŸ¤½','ðŸŽ–ï¸','ðŸ†','ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰','ðŸŽƒ','ðŸŽ„','ðŸŽ†','ðŸŽ‡','ðŸ§¨','âœ¨','ðŸŽˆ','ðŸŽ‰','ðŸŽŠ','ðŸŽ‹','ðŸŽ','ðŸŽŽ','ðŸŽ','ðŸŽ','ðŸŽ‘','ðŸ§§','ðŸŽ€','ðŸŽ','ðŸŽ—ï¸','ðŸŽŸï¸','ðŸŽ«','ðŸŽ ','ðŸŽ¡','ðŸŽ¢','ðŸŽª','ðŸŽ­','ðŸ–¼ï¸','ðŸŽ¨','ðŸ§µ','ðŸª¡','ðŸ§¶','ðŸª¢']
      },
      'Objects': {
        icon: 'ðŸ’¡',
        emojis: ['âŒš','ðŸ“±','ðŸ“²','ðŸ’»','âŒ¨ï¸','ðŸ–¥ï¸','ðŸ–¨ï¸','ðŸ–±ï¸','ðŸ–²ï¸','ðŸ•¹ï¸','ðŸ—œï¸','ðŸ’½','ðŸ’¾','ðŸ’¿','ðŸ“€','ðŸ“¼','ðŸ“·','ðŸ“¸','ðŸ“¹','ðŸŽ¥','ðŸ“½ï¸','ðŸŽžï¸','ðŸ“ž','â˜Žï¸','ðŸ“Ÿ','ðŸ“ ','ðŸ“º','ðŸ“»','ðŸŽ™ï¸','ðŸŽšï¸','ðŸŽ›ï¸','ðŸ§­','â±ï¸','â²ï¸','â°','ðŸ•°ï¸','âŒ›','â³','ðŸ“¡','ðŸ”‹','ðŸ”Œ','ðŸ’¡','ðŸ”¦','ðŸ•¯ï¸','ðŸª”','ðŸ§¯','ðŸ›¢ï¸','ðŸ’¸','ðŸ’µ','ðŸ’´','ðŸ’¶','ðŸ’·','ðŸª™','ðŸ’°','ðŸ’³','ðŸ’Ž','âš–ï¸','ðŸªœ','ðŸ§°','ðŸª›','ðŸ”§','ðŸ”¨','âš’ï¸','ðŸ› ï¸','â›ï¸','ðŸªš','ðŸ”©','âš™ï¸','ðŸª¤','ðŸ§±','â›“ï¸','ðŸ§²','ðŸ”«','ðŸ’£','ðŸ§¨','ðŸª“','ðŸ”ª','ðŸ—¡ï¸','âš”ï¸','ðŸ›¡ï¸','ðŸš¬','âš°ï¸','ðŸª¦','âš±ï¸','ðŸº','ðŸ”®','ðŸ“¿','ðŸ§¿','ðŸ’ˆ','âš—ï¸','ðŸ”­','ðŸ”¬','ðŸ•³ï¸','ðŸ©¹','ðŸ©º','ðŸ’Š','ðŸ’‰','ðŸ©¸','ðŸ§¬','ðŸ¦ ','ðŸ§«','ðŸ§ª','ðŸŒ¡ï¸','ðŸ§¹','ðŸª ','ðŸ§º','ðŸ§»','ðŸš½','ðŸš°','ðŸš¿','ðŸ›','ðŸ›€','ðŸ§¼','ðŸª¥','ðŸª’','ðŸ§½','ðŸª£','ðŸ§´','ðŸ›Žï¸','ðŸ”‘','ðŸ—ï¸','ðŸšª','ðŸª‘','ðŸ›‹ï¸','ðŸ›ï¸','ðŸ›Œ','ðŸ§¸','ðŸª†','ðŸ–¼ï¸','ðŸªž','ðŸªŸ','ðŸ›’','ðŸŽ','ðŸŽˆ','ðŸŽ','ðŸŽ€','ðŸª„','ðŸª…','ðŸŽŠ','ðŸŽ‰','ðŸŽŽ','ðŸ®','ðŸŽ','ðŸ§§','âœ‰ï¸','ðŸ“©','ðŸ“¨','ðŸ“§','ðŸ’Œ','ðŸ“¥','ðŸ“¤','ðŸ“¦','ðŸ·ï¸','ðŸ“ª','ðŸ“«','ðŸ“¬','ðŸ“­','ðŸ“®','ðŸ“¯','ðŸ“œ','ðŸ“ƒ','ðŸ“„','ðŸ“‘','ðŸ§¾','ðŸ“Š','ðŸ“ˆ','ðŸ“‰','ðŸ—’ï¸','ðŸ—“ï¸','ðŸ“†','ðŸ“…','ðŸ—‘ï¸','ðŸ“‡','ðŸ—ƒï¸','ðŸ—³ï¸','ðŸ—„ï¸','ðŸ“‹','ðŸ“','ðŸ“‚','ðŸ—‚ï¸','ðŸ—žï¸','ðŸ“°','ðŸ““','ðŸ“”','ðŸ“’','ðŸ“•','ðŸ“—','ðŸ“˜','ðŸ“™','ðŸ“š','ðŸ“–','ðŸ”–','ðŸ§·','ðŸ”—','ðŸ“Ž','ðŸ–‡ï¸','ðŸ“','ðŸ“','ðŸ§®','ðŸ“Œ','ðŸ“','âœ‚ï¸','ðŸ–Šï¸','ðŸ–‹ï¸','âœ’ï¸','ðŸ–Œï¸','ðŸ–ï¸','ðŸ“','âœï¸','ðŸ”','ðŸ”Ž','ðŸ”','ðŸ”','ðŸ”’','ðŸ”“']
      },
      'Symbols': {
        icon: 'â¤ï¸',
        emojis: ['â¤ï¸','ðŸ§¡','ðŸ’›','ðŸ’š','ðŸ’™','ðŸ’œ','ðŸ–¤','ðŸ¤','ðŸ¤Ž','ðŸ’”','â£ï¸','ðŸ’•','ðŸ’ž','ðŸ’“','ðŸ’—','ðŸ’–','ðŸ’˜','ðŸ’','ðŸ’Ÿ','â˜®ï¸','âœï¸','â˜ªï¸','ðŸ•‰ï¸','â˜¸ï¸','âœ¡ï¸','ðŸ”¯','ðŸ•Ž','â˜¯ï¸','â˜¦ï¸','ðŸ›','â›Ž','â™ˆ','â™‰','â™Š','â™‹','â™Œ','â™','â™Ž','â™','â™','â™‘','â™’','â™“','ðŸ†”','âš›ï¸','ðŸ‰‘','â˜¢ï¸','â˜£ï¸','ðŸ“´','ðŸ“³','ðŸˆ¶','ðŸˆš','ðŸˆ¸','ðŸˆº','ðŸˆ·ï¸','âœ´ï¸','ðŸ†š','ðŸ’®','ðŸ‰','ãŠ™ï¸','ãŠ—ï¸','ðŸˆ´','ðŸˆµ','ðŸˆ¹','ðŸˆ²','ðŸ…°ï¸','ðŸ…±ï¸','ðŸ†Ž','ðŸ†‘','ðŸ…¾ï¸','ðŸ†˜','âŒ','â­•','ðŸ›‘','â›”','ðŸ“›','ðŸš«','ðŸ’¯','ðŸ’¢','â™¨ï¸','ðŸš·','ðŸš¯','ðŸš³','ðŸš±','ðŸ”ž','ðŸ“µ','ðŸš­','â—','â•','â“','â”','â€¼ï¸','â‰ï¸','ðŸ”…','ðŸ”†','ã€½ï¸','âš ï¸','ðŸš¸','ðŸ”±','âšœï¸','ðŸ”°','â™»ï¸','âœ…','ðŸˆ¯','ðŸ’¹','â‡ï¸','âœ³ï¸','âŽ','ðŸŒ','ðŸ’ ','â“‚ï¸','ðŸŒ€','ðŸ’¤','ðŸ§','ðŸš¾','â™¿','ðŸ…¿ï¸','ðŸ›—','ðŸˆ³','ðŸˆ‚ï¸','ðŸ›‚','ðŸ›ƒ','ðŸ›„','ðŸ›…','ðŸš¹','ðŸšº','ðŸš¼','âš§ï¸','ðŸš»','ðŸš®','ðŸŽ¦','ðŸ“¶','ðŸˆ','ðŸ”£','â„¹ï¸','ðŸ”¤','ðŸ”¡','ðŸ” ','ðŸ†–','ðŸ†—','ðŸ†™','ðŸ†’','ðŸ†•','ðŸ†“','0ï¸âƒ£','1ï¸âƒ£','2ï¸âƒ£','3ï¸âƒ£','4ï¸âƒ£','5ï¸âƒ£','6ï¸âƒ£','7ï¸âƒ£','8ï¸âƒ£','9ï¸âƒ£','ðŸ”Ÿ','ðŸ”¢','#ï¸âƒ£','*ï¸âƒ£','âï¸','â–¶ï¸','â¸ï¸','â¯ï¸','â¹ï¸','âºï¸','â­ï¸','â®ï¸','â©','âª','â«','â¬','â—€ï¸','ðŸ”¼','ðŸ”½','âž¡ï¸','â¬…ï¸','â¬†ï¸','â¬‡ï¸','â†—ï¸','â†˜ï¸','â†™ï¸','â†–ï¸','â†•ï¸','â†”ï¸','â†ªï¸','â†©ï¸','â¤´ï¸','â¤µï¸','ðŸ”€','ðŸ”','ðŸ”‚','ðŸ”„','ðŸ”ƒ','âž¿','ðŸ”š','ðŸ”™','ðŸ”›','ðŸ”','ðŸ”œ','âœ”ï¸','â˜‘ï¸','ðŸ”˜','ðŸ”´','ðŸŸ ','ðŸŸ¡','ðŸŸ¢','ðŸ”µ','ðŸŸ£','âš«','âšª','ðŸŸ¤','ðŸ”º','ðŸ”»','ðŸ”¸','ðŸ”¹','ðŸ”¶','ðŸ”·','ðŸ”³','ðŸ”²','â–ªï¸','â–«ï¸','â—¾','â—½','â—¼ï¸','â—»ï¸','ðŸŸ¥','ðŸŸ§','ðŸŸ¨','ðŸŸ©','ðŸŸ¦','ðŸŸª','â¬›','â¬œ','ðŸŸ«','ðŸ”ˆ','ðŸ”‡','ðŸ”‰','ðŸ”Š','ðŸ””','ðŸ”•','ðŸ“£','ðŸ“¢','ðŸ‘ï¸â€ðŸ—¨ï¸','ðŸ’¬','ðŸ’­','ðŸ—¯ï¸','â™ ï¸','â™£ï¸','â™¥ï¸','â™¦ï¸','ðŸƒ','ðŸŽ´','ðŸ€„']
      },
      'Weather': {
        icon: 'â˜€ï¸',
        emojis: ['â˜€ï¸','ðŸŒ¤ï¸','â›…','ðŸŒ¥ï¸','â˜ï¸','ðŸŒ¦ï¸','ðŸŒ§ï¸','â›ˆï¸','ðŸŒ©ï¸','ðŸŒ¨ï¸','â„ï¸','ðŸŒ¬ï¸','ðŸ’¨','ðŸŒªï¸','ðŸŒ«ï¸','ðŸŒˆ','â˜”','âš¡','â„ï¸','ðŸ”¥','ðŸ’§','ðŸŒŠ','â­','ðŸŒŸ','âœ¨','ðŸ’«','ðŸŒ™','ðŸŒ›','ðŸŒœ','ðŸŒ','ðŸŒž','ðŸª','âš¡','â˜„ï¸','ðŸŒ','ðŸŒŽ','ðŸŒ','ðŸŒ‘','ðŸŒ’','ðŸŒ“','ðŸŒ”','ðŸŒ•','ðŸŒ–','ðŸŒ—','ðŸŒ˜']
      },
      'Flags': {
        icon: 'ðŸ³ï¸',
        emojis: ['ðŸ³ï¸','ðŸ´','ðŸ´â€â˜ ï¸','ðŸ','ðŸš©','ðŸŽŒ','ðŸ³ï¸â€ðŸŒˆ','ðŸ³ï¸â€âš§ï¸','ðŸ‡ºðŸ‡¸','ðŸ‡¬ðŸ‡§','ðŸ‡¨ðŸ‡¦','ðŸ‡¦ðŸ‡º','ðŸ‡«ðŸ‡·','ðŸ‡©ðŸ‡ª','ðŸ‡®ðŸ‡¹','ðŸ‡ªðŸ‡¸','ðŸ‡¯ðŸ‡µ','ðŸ‡°ðŸ‡·','ðŸ‡¨ðŸ‡³','ðŸ‡®ðŸ‡³','ðŸ‡§ðŸ‡·','ðŸ‡²ðŸ‡½','ðŸ‡·ðŸ‡º','ðŸ‡¿ðŸ‡¦','ðŸ‡³ðŸ‡±','ðŸ‡§ðŸ‡ª','ðŸ‡¨ðŸ‡­','ðŸ‡¦ðŸ‡¹','ðŸ‡¸ðŸ‡ª','ðŸ‡³ðŸ‡´','ðŸ‡©ðŸ‡°','ðŸ‡«ðŸ‡®','ðŸ‡µðŸ‡±','ðŸ‡®ðŸ‡ª','ðŸ‡µðŸ‡¹','ðŸ‡¬ðŸ‡·','ðŸ‡¹ðŸ‡·','ðŸ‡ªðŸ‡¬','ðŸ‡®ðŸ‡±','ðŸ‡¸ðŸ‡¦','ðŸ‡¦ðŸ‡ª','ðŸ‡¹ðŸ‡­','ðŸ‡»ðŸ‡³','ðŸ‡®ðŸ‡©','ðŸ‡µðŸ‡­','ðŸ‡²ðŸ‡¾','ðŸ‡¸ðŸ‡¬','ðŸ‡³ðŸ‡¿','ðŸ‡¦ðŸ‡·','ðŸ‡¨ðŸ‡±','ðŸ‡¨ðŸ‡´','ðŸ‡µðŸ‡ª','ðŸ‡»ðŸ‡ª']
      }
    };
    let recentEmojis = JSON.parse(localStorage.getItem('cnmn-recent-emojis') || '[]');
    let currentEmojiCategory = 'Smileys';
    let emojiSearchQuery = '';
    let emojiKeywords = null;
    let aiModel = null;

    // Icon picker state
    let pickerMode = {};   // qIndex -> 'emoji' | 'icon'
    let iconResults = {};  // qIndex -> array of { prefix, name }
    const ICON_SET_PRIORITY = ['noto', 'twemoji', 'fluent-emoji-flat', 'fluent-emoji-high-contrast', 'game-icons'];
    const ICON_SET_NAMES = {
      'noto': 'Noto Emoji (Google)',
      'twemoji': 'Twemoji (Twitter)',
      'fluent-emoji-flat': 'Fluent Emoji (Microsoft)',
      'fluent-emoji-high-contrast': 'Fluent Emoji HC',
      'game-icons': 'Game Icons',
    };

    // Token usage tracking
    let tokenUsage = {};  // { stageName: { prompt_tokens, completion_tokens, total_tokens } }

    function addTokenUsage(stageName, usage) {
      if (!usage) return;
      if (!tokenUsage[stageName]) {
        tokenUsage[stageName] = { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 };
      }
      tokenUsage[stageName].prompt_tokens += usage.prompt_tokens || 0;
      tokenUsage[stageName].completion_tokens += usage.completion_tokens || 0;
      tokenUsage[stageName].total_tokens += usage.total_tokens || 0;
    }

    function formatTokenSummary() {
      const stages = Object.entries(tokenUsage).filter(([, u]) => u.total_tokens > 0);
      if (stages.length === 0) return '';
      const totals = stages.reduce((acc, [, u]) => ({
        prompt_tokens: acc.prompt_tokens + u.prompt_tokens,
        completion_tokens: acc.completion_tokens + u.completion_tokens,
        total_tokens: acc.total_tokens + u.total_tokens,
      }), { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 });
      const fmt = n => n.toLocaleString();
      let html = `<div style="margin-top:12px;padding:12px 16px;background:#f5f0eb;border-radius:8px;font-size:13px;color:#6b3410;">`;
      html += `<strong>Tokens:</strong> ${fmt(totals.prompt_tokens)} prompt + ${fmt(totals.completion_tokens)} completion = ${fmt(totals.total_tokens)} total`;
      html += `<div style="font-size:11px;color:#8b6340;margin-top:4px;">`;
      html += stages.map(([name, u]) => `${name}: ${fmt(u.prompt_tokens)}p + ${fmt(u.completion_tokens)}c`).join(' | ');
      html += `</div></div>`;
      return html;
    }

    // Generation state
    let generationAbortController = null;
    let isGenerating = false;
    let availableModels = {};
    let previousThemes = [];
    let existingPuzzleDates = new Set();

    // â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function init() {
      loadEmojiData();
      loadAiModel();
      const select = document.getElementById('dateSelect');
      try {
        const resp = await fetch('/api/puzzle-dates');
        const dates = await resp.json();
        if (dates.length === 0) {
          select.innerHTML = '<option value="">No puzzles found</option>';
          return;
        }
        const latestDate = dates[dates.length - 1].date;
        previousThemes = dates.map(d => d.theme).filter(Boolean).slice(-100);
        existingPuzzleDates = new Set(dates.map(d => d.date));
        select.innerHTML = dates.map(d =>
          `<option value="${d.date}" ${d.date === latestDate ? 'selected' : ''}>${d.date}${d.theme ? ' â€” ' + d.theme : ''}</option>`
        ).join('');
        // Auto-load most recent (last in sorted list)
        loadPuzzle(dates[dates.length - 1].date);
      } catch (e) {
        select.innerHTML = '<option value="">Failed to load dates</option>';
      }
    }

    // â”€â”€ Load puzzle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function loadPuzzle(date) {
      if (!date) return;
      const container = document.getElementById('questionsContainer');
      container.innerHTML = '<div class="loading"><div class="spinner"></div>Loading puzzle...</div>';

      try {
        const resp = await fetch(`/api/puzzle/${date}`);
        if (!resp.ok) {
          const err = await resp.json();
          container.innerHTML = `<div class="empty-state"><h3>Error</h3><p>${err.error || 'Failed to load puzzle'}</p></div>`;
          return;
        }
        puzzle = await resp.json();
        originalJson = JSON.stringify(puzzle);
        dirty = false;
        updateDirtyIndicator();

        document.getElementById('themeInput').value = puzzle.theme || '';
        document.getElementById('pubDateInput').value = puzzle.publicationDate || '';

        renderPuzzle();
      } catch (e) {
        container.innerHTML = `<div class="empty-state"><h3>Error</h3><p>${e.message}</p></div>`;
      }
    }

    // â”€â”€ Render â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function renderPuzzle() {
      if (!puzzle || !puzzle.questions) return;
      const container = document.getElementById('questionsContainer');
      let html = '';
      if (generationTranscript) {
        html += renderGenerationSummary(false);
      }
      html += '<div class="questions-grid">' +
        puzzle.questions.map((q, i) => renderQuestionCard(q, i)).join('') +
        '</div>';
      container.innerHTML = html;
    }

    function renderQuestionCard(q, index) {
      const total = puzzle.questions.length;
      const diffOptions = ['easy', 'medium', 'hard'];

      const distractorsHtml = (q.distractors || []).map((d, di) => `
        <div class="field-row">
          <label>Word</label>
          <input type="text" value="${escapeAttr(d.word || '')}" onchange="updateDistractorField(${index}, ${di}, 'word', this.value)">
          <input type="text" class="disguise-input" value="${escapeAttr(d.disguise || '')}" onchange="updateDistractorField(${index}, ${di}, 'disguise', this.value)">
          <button class="small secondary" onclick="regenDistractorDisguise(${index}, ${di})" title="Re-derive disguise">&#x1f504;</button>
          <span class="type-badge ${d.type || ''}" onclick="cycleType(${index}, ${di})" title="Click to cycle type">${d.type || 'unknown'}</span>
        </div>
      `).join('');

      return `
        <div class="question-card">
          <div class="card-header">
            <span class="num">${index + 1}</span>
            <span class="difficulty-badge ${q.difficulty || ''}">${q.difficulty || 'unset'}</span>
            <div class="move-buttons">
              <button class="small" onclick="moveQuestion(${index}, -1)" ${index === 0 ? 'disabled' : ''} title="Move up">&uarr;</button>
              <button class="small" onclick="moveQuestion(${index}, 1)" ${index === total - 1 ? 'disabled' : ''} title="Move down">&darr;</button>
            </div>
          </div>
          <div class="field-row">
            <label>Prompt</label>
            <input type="text" value="${escapeAttr(q.prompt || '')}" onchange="updateField(${index}, 'prompt', this.value)">
          </div>
          <div class="field-row">
            <label>Emoji</label>
            <div class="emoji-picker-container">
              ${q.imageUrl
                ? `<div class="image-preview" onclick="toggleEmojiPicker(${index})"><img src="${escapeAttr(q.imageUrl)}" alt="icon"></div>`
                : `<button type="button" class="emoji-btn" onclick="toggleEmojiPicker(${index})">${q.emoji || 'âž•'}</button>`
              }
              <div class="emoji-dropdown" id="emoji-dropdown-${index}">
                <div class="image-picker-toggle">
                  <button type="button" class="${(pickerMode[index] || 'emoji') === 'emoji' ? 'active' : ''}" onclick="setPickerMode(${index}, 'emoji')">Emoji</button>
                  <button type="button" class="${(pickerMode[index] || 'emoji') === 'icon' ? 'active' : ''}" onclick="setPickerMode(${index}, 'icon')">Icon</button>
                </div>
                <div id="picker-emoji-${index}" style="display:${(pickerMode[index] || 'emoji') === 'emoji' ? 'block' : 'none'}">
                  <div class="emoji-search">
                    <input type="text" placeholder="Search emojis..." oninput="filterEmojis(${index}, this.value)" id="emoji-search-${index}">
                  </div>
                  <div class="emoji-tabs" id="emoji-tabs-${index}">
                    ${Object.entries(emojiCategories).map(([name, cat]) =>
                      `<button type="button" class="emoji-tab ${name === currentEmojiCategory ? 'active' : ''}" onclick="switchEmojiCategory(${index}, '${name}')" title="${name}">${cat.icon}</button>`
                    ).join('')}
                  </div>
                  <div class="emoji-grid-container" id="emoji-grid-${index}">
                    ${renderEmojiGrid(index)}
                  </div>
                  <div class="emoji-footer">
                    <button type="button" class="emoji-clear" onclick="selectEmoji(${index}, '')">Clear</button>
                    <button type="button" class="emoji-ai-suggest" id="emoji-ai-btn-${index}" onclick="suggestEmojiAI(${index})" ${!aiModel ? 'disabled title="No AI model available"' : ''}>Ask AI</button>
                    <input type="text" class="emoji-direct-input" placeholder="Paste emoji" id="emoji-direct-${index}" onkeydown="handleDirectEmoji(event, ${index})" maxlength="2">
                  </div>
                </div>
                <div id="picker-icon-${index}" style="display:${(pickerMode[index] || 'emoji') === 'icon' ? 'block' : 'none'}">
                  <div class="icon-search-row">
                    <input type="text" placeholder="Search icons..." id="icon-search-${index}"
                      value="${escapeAttr(q.prompt || '')}"
                      onkeydown="if(event.key==='Enter'){searchIcons(${index});event.preventDefault()}">
                    <button type="button" onclick="searchIcons(${index})">Search</button>
                  </div>
                  <div class="icon-grid" id="icon-grid-${index}">
                    ${renderIconGrid(index)}
                  </div>
                  <div class="icon-footer">
                    <button type="button" class="emoji-clear" onclick="clearImage(${index})">Clear icon</button>
                    <span>Icons by Iconify</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="field-row">
            <label>Answer</label>
            <input type="text" value="${escapeAttr(q.answer || '')}" onchange="updateField(${index}, 'answer', this.value)">
            <input type="text" class="disguise-input" value="${escapeAttr(q.answerDisguise || '')}" onchange="updateField(${index}, 'answerDisguise', this.value)">
            <button class="small secondary" onclick="regenDisguise(${index})" title="Re-derive disguise">&#x1f504;</button>
          </div>
          <div class="field-row">
            <label>Display</label>
            <input type="text" value="${escapeAttr(q.correctOption || '')}" onchange="updateField(${index}, 'correctOption', this.value)" placeholder="correctOption">
          </div>
          <div class="field-row">
            <label>Difficulty</label>
            <select class="difficulty-select" onchange="updateField(${index}, 'difficulty', this.value)">
              ${diffOptions.map(d => `<option value="${d}" ${q.difficulty === d ? 'selected' : ''}>${d}</option>`).join('')}
            </select>
          </div>
          <div class="distractors-section">
            <div class="distractors-header">
              <label>Distractors</label>
            </div>
            ${distractorsHtml}
          </div>
        </div>
      `;
    }

    // â”€â”€ Editing helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function updateField(qIndex, field, value) {
      puzzle.questions[qIndex][field] = value;
      markDirty();
    }

    function updateDistractorField(qIndex, dIndex, field, value) {
      puzzle.questions[qIndex].distractors[dIndex][field] = value;
      markDirty();
    }

    function updateMeta(field, value) {
      puzzle[field] = value;
      markDirty();
    }

    function cycleType(qIndex, dIndex) {
      const types = ['wrong-letters', 'non-synonym', 'phonetic-trap'];
      const d = puzzle.questions[qIndex].distractors[dIndex];
      const cur = types.indexOf(d.type);
      d.type = types[(cur + 1) % types.length];
      markDirty();
      renderPuzzle();
    }

    function moveQuestion(qIndex, direction) {
      const target = qIndex + direction;
      if (target < 0 || target >= puzzle.questions.length) return;
      const q = puzzle.questions;
      [q[qIndex], q[target]] = [q[target], q[qIndex]];
      markDirty();
      renderPuzzle();
    }

    // â”€â”€ Disguise helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function generateDisguiseRuleBased(word) {
      if (!word) return '';
      const lower = word.toLowerCase();
      let disguise = lower
        .replace(/tion$/i, 'shn')
        .replace(/sion$/i, 'zhn')
        .replace(/age$/i, 'j')
        .replace(/dge$/i, 'j')
        .replace(/ght$/i, 't')
        .replace(/ck/g, 'k')
        .replace(/ph/g, 'f')
        .replace(/wh/g, 'w')
        .replace(/wr/g, 'r')
        .replace(/kn/g, 'n')
        .replace(/[aeiou]/g, '');

      if (disguise.length < 2) {
        disguise = lower.replace(/[aeiou](?=[aeiou])/g, '').replace(/[aeiou]$/g, '');
      }
      return disguise || lower.substring(0, 3);
    }

    function regenDisguise(qIndex) {
      const q = puzzle.questions[qIndex];
      q.answerDisguise = generateDisguiseRuleBased(q.answer);
      markDirty();
      renderPuzzle();
      flashDisguiseInput(qIndex);
    }

    function regenDistractorDisguise(qIndex, dIndex) {
      const d = puzzle.questions[qIndex].distractors[dIndex];
      d.disguise = generateDisguiseRuleBased(d.word);
      markDirty();
      renderPuzzle();
      flashDisguiseInput(qIndex, dIndex);
    }

    function flashDisguiseInput(qIndex, dIndex) {
      const cards = document.querySelectorAll('.question-card');
      const card = cards[qIndex];
      if (!card) return;
      const idx = dIndex === undefined ? 0 : dIndex + 1;
      const input = card.querySelectorAll('.disguise-input')[idx];
      if (input) {
        input.classList.add('flash');
        setTimeout(() => input.classList.remove('flash'), 400);
      }
    }

    function regenAllDisguises() {
      if (!puzzle || !puzzle.questions) return;
      puzzle.questions.forEach(q => {
        q.answerDisguise = generateDisguiseRuleBased(q.answer);
        (q.distractors || []).forEach(d => {
          d.disguise = generateDisguiseRuleBased(d.word);
        });
      });
      markDirty();
      renderPuzzle();
      showToast('All disguises re-derived');
    }

    // â”€â”€ Generation pipeline helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function consonantSkeleton(word) {
      return word.toLowerCase().replace(/[aeiou]/g, '');
    }

    function collapseRuns(s) {
      return s.replace(/(.)\1+/g, '$1');
    }

    function parseJsonResponse(text) {
      const m = text.match(/```(?:json)?\s*\n?([\s\S]*?)\n?\s*```/);
      if (m) text = m[1];
      return JSON.parse(text.trim());
    }

    function disguiseWithKeptVowel(word) {
      let d = word.toLowerCase();
      d = d.replace(/tion$/, 'shn').replace(/sion$/, 'zhn');
      d = d.replace(/age$/, 'j').replace(/dge$/, 'j').replace(/ght$/, 't');
      d = d.replace(/ck/g, 'k').replace(/ph/g, 'f').replace(/wh/g, 'w');
      d = d.replace(/wr/g, 'r').replace(/kn/g, 'n');
      const chars = d.split('');
      let kept = false;
      for (let idx = 1; idx < chars.length - 1; idx++) {
        if ('aeiou'.includes(chars[idx]) && !kept) {
          kept = true;
        } else if ('aeiou'.includes(chars[idx])) {
          chars[idx] = '';
        }
      }
      let result = chars.join('');
      if (result && 'aeiou'.includes(result[0])) result = result.slice(1);
      if (result && 'aeiou'.includes(result[result.length - 1])) result = result.slice(0, -1);
      return result || word.toLowerCase().slice(0, 3);
    }

    function resolveDisguiseCollisions(answerDisguise, distractorDisguises, answerWord, distractorWords) {
      distractorWords = distractorWords || distractorDisguises.map(() => '');
      const all = [answerDisguise, ...distractorDisguises];
      if (new Set(all).size === all.length) return [answerDisguise, distractorDisguises];
      const taken = new Set([answerDisguise]);
      for (let i = 0; i < distractorDisguises.length; i++) {
        if (taken.has(distractorDisguises[i])) {
          const alt = distractorWords[i] ? disguiseWithKeptVowel(distractorWords[i]) : distractorDisguises[i];
          if (alt !== distractorDisguises[i] && !taken.has(alt)) {
            distractorDisguises[i] = alt;
          } else {
            const first = distractorWords[i] ? distractorWords[i][0].toLowerCase() : String(i);
            distractorDisguises[i] = first + distractorDisguises[i];
          }
        }
        taken.add(distractorDisguises[i]);
      }
      return [answerDisguise, distractorDisguises];
    }

    // â”€â”€ Generation prompts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const STAGE1_PROMPT = `You are generating puzzle content for a word-guessing game called CNMN ("Consonant Moon").

Theme: "{theme}"

Generate exactly 6 prompt/answer pairs that fit this theme. Each pair has:
- "prompt": a specific noun or thing that is an EXAMPLE of the theme â€” not an adjective, feeling, or loosely related concept. For "Winter Clothing" use garment names like "jacket", "mittens", "scarf" â€” NOT "cold", "cozy", "frosty".
- "answer": a synonym or strongly-associated word for the prompt (what players must guess). Must be a word that everyday English speakers would recognize â€” no foreign-language words, technical jargon, or obscure vocabulary.
- "emoji": a single emoji that represents the prompt (or empty string if none fits)

Rules:
- All words must be common English words
- Every prompt must be a concrete instance/example of the theme category
- Answers should be interesting synonyms â€” not the most obvious choice
- No duplicate prompts or answers across the 6 pairs
- Prompt and answer must be different words for each pair
- Answers should vary in length (mix of short and long words)
- Order from easiest to hardest synonym relationship

Return ONLY a JSON array, no other text:
[{"prompt": "word1", "answer": "WORD2", "emoji": "ðŸŽ¯"}, ...]`;

    const STAGE3_PROMPT = `For a word-guessing puzzle, the player sees a clue "{prompt}" and must pick the synonym "{answer}" from four disguised options (vowels stripped).

The answer's consonant skeleton is "{skeleton}".

Generate exactly 3 distractor words. Each distractor must:
- Be a real, common English word
- NOT be a synonym of "{prompt}"
- Have a consonant skeleton DIFFERENT from "{skeleton}"
- Be plausible enough to trick a player (related to the theme or similar-looking when disguised)

Assign each distractor one of these types:
- "wrong-letters": a word whose disguise looks similar but decodes to something wrong
- "non-synonym": a thematically related word that isn't actually a synonym
- "phonetic-trap": a word that sounds vaguely similar when consonants are read aloud

Return ONLY a JSON array:
[{"word": "EXAMPLE", "type": "wrong-letters"}, ...]`;

    const STAGE5_PROMPT = `You are playing the word puzzle CNMN. For each question you see a clue word and 4 disguised options (vowels stripped, phonetic shortcuts applied). Pick the synonym of the clue.

For each question:
1. Try to decode each disguised option back into a real word
2. Pick the one that is a synonym of the clue
3. Rate your confidence (1-5)

{questions_text}

Return ONLY JSON:
[{"question": 1, "picked": "B", "decoded": "FRIGID", "confidence": 4}, ...]`;

    // â”€â”€ Generation stage functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function callServerWithModel(prompt, model, signal) {
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model, prompt }),
        signal,
      });
      const data = await response.json();
      if (!response.ok || data.error) throw new Error(data.error || 'Server error');
      return { content: data.content, usage: data.usage || null };
    }

    async function genStage1(theme, model, signal) {
      const prompt = STAGE1_PROMPT.replace('{theme}', theme);
      const { content, usage } = await callServerWithModel(prompt, model, signal);
      addTokenUsage('Stage 1: Word Pairs', usage);
      return parseJsonResponse(content);
    }

    function genStage2(pairs) {
      const errors = [];
      if (pairs.length !== 6) { errors.push(`Expected 6 pairs, got ${pairs.length}`); return [false, errors]; }
      const prompts = [], answers = [], skeletons = [];
      for (let i = 0; i < pairs.length; i++) {
        const pw = (pairs[i].prompt || '').trim();
        const aw = (pairs[i].answer || '').trim();
        if (!pw || !aw) { errors.push(`Pair ${i+1}: missing prompt or answer`); continue; }
        if (pw.toLowerCase() === aw.toLowerCase()) errors.push(`Pair ${i+1}: prompt == answer`);
        prompts.push(pw.toLowerCase());
        answers.push(aw.toUpperCase());
        skeletons.push(consonantSkeleton(aw));
      }
      if (new Set(prompts).size !== prompts.length) errors.push('Duplicate prompts');
      if (new Set(answers).size !== answers.length) errors.push('Duplicate answers');
      if (new Set(skeletons).size !== skeletons.length) {
        const seen = {};
        skeletons.forEach((sk, i) => {
          if (seen[sk] !== undefined) errors.push(`Skeleton collision: "${answers[i]}" and "${answers[seen[sk]]}"`);
          seen[sk] = i;
        });
      }
      return [errors.length === 0, errors];
    }

    async function genStage3Single(pair, model, signal) {
      const skeleton = consonantSkeleton(pair.answer);
      const answerUpper = pair.answer.toUpperCase();
      const promptUpper = pair.prompt.toUpperCase();
      const answerDisguiseNorm = collapseRuns(generateDisguiseRuleBased(answerUpper));
      const prompt = STAGE3_PROMPT
        .replace(/\{prompt\}/g, pair.prompt)
        .replace(/\{answer\}/g, pair.answer)
        .replace(/\{skeleton\}/g, skeleton);
      const { content, usage } = await callServerWithModel(prompt, model, signal);
      addTokenUsage('Stage 3: Distractors', usage);
      const distractors = parseJsonResponse(content);
      const valid = [];
      for (const d of distractors) {
        d.word = (d.word || '').toUpperCase();
        if (!d.word) continue;
        if (d.word === answerUpper || d.word === promptUpper) continue;
        if (consonantSkeleton(d.word) === skeleton) continue;
        if (collapseRuns(generateDisguiseRuleBased(d.word)) === answerDisguiseNorm) continue;
        valid.push(d);
      }
      return valid.length >= 3 ? valid.slice(0, 3) : distractors.slice(0, 3);
    }

    async function genStage3Parallel(pairs, model, signal, onProgress) {
      const results = new Array(pairs.length).fill(null);
      const promises = pairs.map(async (pair, i) => {
        let distractors = [];
        for (let attempt = 0; attempt <= 2; attempt++) {
          try {
            distractors = await genStage3Single(pair, model, signal);
            if (distractors.length >= 3) break;
          } catch (e) {
            if (e.name === 'AbortError') throw e;
            if (attempt === 2) console.warn(`Q${i+1}: distractor gen failed:`, e);
          }
        }
        results[i] = distractors;
        if (onProgress) onProgress(i);
      });
      await Promise.all(promises);
      return results;
    }

    function genStage4(pairs, allDistractors) {
      const questions = [];
      for (let i = 0; i < pairs.length; i++) {
        const answer = pairs[i].answer.toUpperCase();
        let answerDisguise = generateDisguiseRuleBased(answer);
        const dList = allDistractors[i] || [];
        let dDisguises = dList.map(d => generateDisguiseRuleBased(d.word));
        const dWords = dList.map(d => d.word);
        [answerDisguise, dDisguises] = resolveDisguiseCollisions(answerDisguise, dDisguises, answer, dWords);
        const distractorsOut = dList.map((d, j) => ({
          word: d.word.toUpperCase(),
          disguise: j < dDisguises.length ? dDisguises[j] : generateDisguiseRuleBased(d.word),
          type: d.type || 'non-synonym',
        }));
        const difficulty = i < 2 ? 'easy' : i < 4 ? 'medium' : 'hard';
        questions.push({
          prompt: pairs[i].prompt.toLowerCase(),
          emoji: pairs[i].emoji || '',
          answer,
          answerDisguise,
          distractors: distractorsOut,
          difficulty,
          correctOption: answer.charAt(0).toUpperCase() + answer.slice(1).toLowerCase(),
        });
      }
      return questions;
    }

    function buildPlaytesterQuestions(questions) {
      const answerKey = [];
      const lines = [];
      for (let i = 0; i < questions.length; i++) {
        const q = questions[i];
        const options = [
          { label: '', disguise: q.answerDisguise, isAnswer: true },
          ...q.distractors.map(d => ({ label: '', disguise: d.disguise, isAnswer: false })),
        ];
        // Shuffle options
        for (let j = options.length - 1; j > 0; j--) {
          const k = Math.floor(Math.random() * (j + 1));
          [options[j], options[k]] = [options[k], options[j]];
        }
        const labels = ['A', 'B', 'C', 'D'];
        let correctLabel = '';
        const optionParts = [];
        for (let j = 0; j < options.length && j < 4; j++) {
          options[j].label = labels[j];
          optionParts.push(`${labels[j]}: ${options[j].disguise}`);
          if (options[j].isAnswer) correctLabel = labels[j];
        }
        answerKey.push({ qIndex: i, correctLabel });
        lines.push(`Q${i + 1}. Clue: "${q.prompt}" | ${optionParts.join('  ')}`);
      }
      return { questionsText: lines.join('\n'), answerKey };
    }

    async function genStage5(questions, theme, model, signal) {
      const { questionsText, answerKey } = buildPlaytesterQuestions(questions);
      const prompt = STAGE5_PROMPT.replace('{questions_text}', questionsText);
      const { content, usage } = await callServerWithModel(prompt, model, signal);
      addTokenUsage('Stage 5: Playtester', usage);

      let picks;
      try { picks = parseJsonResponse(content); } catch (e) { return { issues: [], picks: [], answerKey }; }

      const issues = [];
      let correctCount = 0;
      let allMaxConfidence = true;

      for (const pick of picks) {
        const qNum = pick.question;
        const keyEntry = answerKey.find(k => k.qIndex === qNum - 1);
        if (!keyEntry) continue;

        if (pick.picked !== keyEntry.correctLabel) {
          issues.push({
            question: qNum,
            severity: 'high',
            issue: `Playtester picked wrong answer (chose ${pick.picked}, correct was ${keyEntry.correctLabel}) â€” synonym relationship may be unclear or distractors too similar`,
          });
        } else {
          correctCount++;
          if (pick.confidence <= 2) {
            issues.push({
              question: qNum,
              severity: 'low',
              issue: `Playtester unsure (confidence ${pick.confidence}/5) â€” question may be too hard`,
            });
          }
        }
        if (pick.confidence < 5) allMaxConfidence = false;
      }

      if (allMaxConfidence && picks.length === questions.length) {
        issues.push({
          question: 0,
          severity: 'low',
          issue: 'All max confidence â€” puzzle may be too easy',
        });
      }

      return { issues, picks, answerKey };
    }

    async function genStage6(questions, issues, pairs, model, signal) {
      const highIssues = issues.filter(i => i.severity === 'high');
      if (!highIssues.length) return questions;
      const flagged = new Set();
      for (const iss of highIssues) {
        const qNum = iss.question || 0;
        if (qNum >= 1 && qNum <= questions.length) flagged.add(qNum - 1);
      }
      if (!flagged.size) return questions;
      for (const idx of flagged) {
        try {
          const newDistractors = await genStage3Single(pairs[idx], model, signal);
          if (newDistractors.length < 3) continue;
          const answer = pairs[idx].answer.toUpperCase();
          let answerDisguise = generateDisguiseRuleBased(answer);
          let dDisguises = newDistractors.map(d => generateDisguiseRuleBased(d.word));
          const dWords = newDistractors.map(d => d.word);
          [answerDisguise, dDisguises] = resolveDisguiseCollisions(answerDisguise, dDisguises, answer, dWords);
          questions[idx].answerDisguise = answerDisguise;
          questions[idx].distractors = newDistractors.slice(0, 3).map((d, j) => ({
            word: d.word.toUpperCase(),
            disguise: dDisguises[j],
            type: d.type || 'non-synonym',
          }));
        } catch (e) {
          if (e.name === 'AbortError') throw e;
          console.warn(`Q${idx+1}: regen failed`, e);
        }
      }
      return questions;
    }

    // â”€â”€ Generation UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function toggleGeneratePanel() {
      const panel = document.getElementById('generatePanel');
      panel.classList.toggle('hidden');
      if (!panel.classList.contains('hidden')) {
        // Find next future date with no existing puzzle
        const candidate = new Date();
        candidate.setDate(candidate.getDate() + 1);
        while (existingPuzzleDates.has(candidate.toISOString().split('T')[0])) {
          candidate.setDate(candidate.getDate() + 1);
        }
        document.getElementById('genDateInput').value = candidate.toISOString().split('T')[0];
        updateGenButtonState();
        suggestGenThemes();
      }
    }

    async function suggestGenThemes() {
      const input = document.getElementById('genThemeInput');
      const model = document.getElementById('genModelSelect').value;
      if (!previousThemes.length || !model) {
        input.placeholder = 'e.g., Ocean Animals, Emotions, Weather';
        return;
      }
      input.classList.add('ideating');
      let dots = 0;
      const dotTimer = setInterval(() => {
        dots = (dots + 1) % 4;
        input.placeholder = 'ideating on new themes' + '.'.repeat(dots);
      }, 400);
      try {
        const themeList = previousThemes.join(', ');
        const { content, usage } = await callServerWithModel(
          `Here are themes already used for a daily word puzzle game: ${themeList}\n\nSuggest 4 fresh, diverse theme ideas that haven't been used yet. Reply with ONLY the 4 themes separated by commas, nothing else.`,
          model, null
        );
        addTokenUsage('Theme Suggestions', usage);
        const suggestions = content.trim();
        if (suggestions) {
          input.placeholder = `e.g., ${suggestions}`;
        }
      } catch {
        input.placeholder = 'e.g., Ocean Animals, Emotions, Weather';
      }
      clearInterval(dotTimer);
      input.classList.remove('ideating');
    }

    function updateGenButtonState() {
      const theme = document.getElementById('genThemeInput').value.trim();
      const date = document.getElementById('genDateInput').value;
      const model = document.getElementById('genModelSelect').value;
      const count = parseInt(document.getElementById('genCountInput').value) || 0;
      const btn = document.getElementById('genStartBtn');
      btn.disabled = !theme || !date || !model || count < 1 || count > 10 || isGenerating;
    }

    function populateGenModelSelect(modelIds) {
      const select = document.getElementById('genModelSelect');
      if (!modelIds || modelIds.length === 0) {
        select.innerHTML = '<option value="">No models available</option>';
        return;
      }
      const preferred = modelIds.find(id => id.includes('sonnet')) || modelIds[0];
      select.innerHTML = modelIds.map(id =>
        `<option value="${id}" ${id === preferred ? 'selected' : ''}>${availableModels[id]?.name || id}</option>`
      ).join('');
      updateGenButtonState();
    }

    function renderGenerationProgress(stages, puzzleNum, totalPuzzles, showTokens) {
      const container = document.getElementById('questionsContainer');
      let html = '<div class="generation-progress">';
      if (totalPuzzles > 1) {
        html += `<div class="progress-puzzle-count">Puzzle ${puzzleNum} of ${totalPuzzles}</div>`;
      }
      for (const stage of stages) {
        let icon = '';
        if (stage.status === 'completed') icon = '&#10003;';
        else if (stage.status === 'active') icon = '<span class="progress-spinner-inline"></span>';
        else if (stage.status === 'error') icon = '&#10007;';
        else icon = '&middot;';
        html += `<div class="progress-stage ${stage.status}">`;
        html += `<span class="stage-icon">${icon}</span>`;
        html += `<span>${escapeAttr(stage.label)}</span>`;
        html += '</div>';
        if (stage.detail) {
          html += `<div class="progress-detail">${escapeAttr(stage.detail)}</div>`;
        }
      }
      if (showTokens) html += formatTokenSummary();
      html += '</div>';
      container.innerHTML = html;
    }

    function renderGenerationSummary(expanded) {
      const gt = generationTranscript;
      if (!gt) return '';

      const sd = gt.stageData || {};
      const tokenEntries = Object.entries(gt.tokenUsage || {}).filter(([, u]) => u.total_tokens > 0);
      const totalTokens = tokenEntries.reduce((sum, [, u]) => sum + u.total_tokens, 0);
      const completedStages = gt.stages.filter(s => s.status === 'completed').length;

      let html = `<div class="gen-summary ${expanded ? 'expanded' : ''}">`;
      html += `<div class="gen-summary-bar" onclick="toggleGenSummary()">`;
      html += `<span>Generation summary: ${completedStages} stages completed | Tokens: ${totalTokens.toLocaleString()}</span>`;
      html += `<span class="gen-summary-arrow">&#9660;</span>`;
      html += `</div>`;
      html += `<div class="gen-summary-body">`;

      for (let i = 0; i < gt.stages.length; i++) {
        const stage = gt.stages[i];
        let icon = '';
        if (stage.status === 'completed') icon = '&#10003;';
        else if (stage.status === 'error') icon = '&#10007;';
        else icon = '&middot;';

        html += `<div class="progress-stage ${stage.status}">`;
        html += `<span class="stage-icon">${icon}</span>`;
        html += `<span>${escapeAttr(stage.label)}</span>`;
        html += `</div>`;
        if (stage.detail) {
          html += `<div class="progress-detail">${escapeAttr(stage.detail)}</div>`;
        }

        // Stage-specific transcripts
        if (i === 0 && sd.stage1) {
          html += renderStage1Transcript(sd.stage1);
        } else if (i === 1 && sd.stage2) {
          html += renderStage2Transcript(sd.stage2);
        } else if (i === 2 && sd.stage3) {
          html += renderStage3Transcript(sd.stage3, sd.stage1);
        } else if (i === 4 && sd.stage5) {
          html += renderStage5Transcript(sd.stage5, sd.stage1);
        } else if (i === 5 && sd.stage6) {
          html += renderStage6Transcript(sd.stage6, sd.stage1);
        }
      }

      // Token summary
      if (tokenEntries.length > 0) {
        const fmt = n => n.toLocaleString();
        const totals = tokenEntries.reduce((acc, [, u]) => ({
          prompt_tokens: acc.prompt_tokens + u.prompt_tokens,
          completion_tokens: acc.completion_tokens + u.completion_tokens,
          total_tokens: acc.total_tokens + u.total_tokens,
        }), { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 });
        html += `<div style="margin-top:8px;padding:8px 16px;background:#f5f0eb;border-radius:8px;font-size:12px;color:#6b3410;">`;
        html += `<strong>Tokens:</strong> ${fmt(totals.prompt_tokens)} prompt + ${fmt(totals.completion_tokens)} completion = ${fmt(totals.total_tokens)} total`;
        html += `<div style="font-size:11px;color:#8b6340;margin-top:2px;">`;
        html += tokenEntries.map(([name, u]) => `${name}: ${fmt(u.prompt_tokens)}p + ${fmt(u.completion_tokens)}c`).join(' | ');
        html += `</div></div>`;
      }

      html += `</div></div>`;
      return html;
    }

    function renderStage1Transcript(data) {
      const pairs = data.pairs || [];
      if (!pairs.length) return '';
      let html = '<div class="stage-transcript">';
      html += pairs.map((p, i) =>
        `${i + 1}. ${escapeAttr(p.prompt)} &rarr; ${escapeAttr(p.answer.toUpperCase())} ${p.emoji || ''}`
      ).join('&nbsp;&nbsp;&nbsp;');
      html += '</div>';
      return html;
    }

    function renderStage2Transcript(data) {
      let html = '<div class="stage-transcript">';
      if (data.ok) {
        html += 'Validation passed';
      } else {
        html += (data.errors || []).map(e => escapeAttr(e)).join('; ');
      }
      html += '</div>';
      return html;
    }

    function renderStage3Transcript(data, stage1Data) {
      const distractors = data.distractors || [];
      const pairs = (stage1Data && stage1Data.pairs) || [];
      if (!distractors.length) return '';
      let html = '<div class="stage-transcript">';
      for (let i = 0; i < distractors.length; i++) {
        const prompt = pairs[i] ? pairs[i].prompt : `Q${i + 1}`;
        const dList = distractors[i] || [];
        const dStr = dList.map(d => `${escapeAttr(d.word)} (${escapeAttr(d.type || 'unknown')})`).join(', ');
        html += `Q${i + 1} &ldquo;${escapeAttr(prompt)}&rdquo;: ${dStr}<br>`;
      }
      html += '</div>';
      return html;
    }

    function renderStage5Transcript(data, stage1Data) {
      const picks = data.picks || [];
      const answerKey = data.answerKey || [];
      const pairs = (stage1Data && stage1Data.pairs) || [];
      if (!picks.length) return '';
      let html = '<div class="stage-transcript">';
      for (const pick of picks) {
        const qIdx = pick.question - 1;
        const prompt = pairs[qIdx] ? pairs[qIdx].prompt : `Q${pick.question}`;
        const keyEntry = answerKey.find(k => k.qIndex === qIdx);
        const isCorrect = keyEntry && pick.picked === keyEntry.correctLabel;
        const indicator = isCorrect
          ? '<span class="pick-correct">&#10003;</span>'
          : `<span class="pick-wrong">&#10007; (correct: ${keyEntry ? keyEntry.correctLabel : '?'})</span>`;
        html += `Q${pick.question} &ldquo;${escapeAttr(prompt)}&rdquo; &rarr; picked ${escapeAttr(pick.picked)}: ${escapeAttr(pick.decoded || '?')} (confidence ${pick.confidence}/5) ${indicator}<br>`;
      }
      html += '</div>';
      return html;
    }

    function renderStage6Transcript(data, stage1Data) {
      const flagged = data.flagged || [];
      const pairs = (stage1Data && stage1Data.pairs) || [];
      let html = '<div class="stage-transcript">';
      if (flagged.length === 0) {
        html += 'No regeneration needed';
      } else {
        const qNames = flagged.map(idx => {
          const prompt = pairs[idx] ? pairs[idx].prompt : `Q${idx + 1}`;
          return `Q${idx + 1} &ldquo;${escapeAttr(prompt)}&rdquo;`;
        });
        html += `Regenerated: ${qNames.join(', ')}`;
      }
      html += '</div>';
      return html;
    }

    function toggleGenSummary() {
      document.querySelector('.gen-summary')?.classList.toggle('expanded');
    }

    function cancelGeneration() {
      if (generationAbortController) {
        generationAbortController.abort();
        generationAbortController = null;
      }
      isGenerating = false;
      document.getElementById('genStartBtn').disabled = false;
      document.getElementById('genCancelBtn').classList.add('hidden');
      showToast('Generation cancelled');
      if (puzzle) renderPuzzle();
      else document.getElementById('questionsContainer').innerHTML =
        '<div class="empty-state"><h3>No puzzle loaded</h3><p>Select a date above to load a puzzle.</p></div>';
    }

    async function startGeneration() {
      const theme = document.getElementById('genThemeInput').value.trim();
      const startDate = document.getElementById('genDateInput').value;
      const model = document.getElementById('genModelSelect').value;
      const count = parseInt(document.getElementById('genCountInput').value) || 1;
      if (!theme || !startDate || !model) return;

      isGenerating = true;
      tokenUsage = {};
      generationAbortController = new AbortController();
      const signal = generationAbortController.signal;
      document.getElementById('genStartBtn').disabled = true;
      document.getElementById('genCancelBtn').classList.remove('hidden');

      let lastGeneratedDate = null;
      try {
        for (let n = 0; n < count; n++) {
          const d = new Date(startDate + 'T00:00:00');
          d.setDate(d.getDate() + n);
          const dateStr = d.toISOString().split('T')[0];
          lastGeneratedDate = dateStr;

          const stages = [
            { label: 'Stage 1: Generate word pairs', status: 'pending' },
            { label: 'Stage 2: Validate pairs', status: 'pending' },
            { label: 'Stage 3: Generate distractors', status: 'pending' },
            { label: 'Stage 4: Generate disguises', status: 'pending' },
            { label: 'Stage 5: Playtester review', status: 'pending' },
            { label: 'Stage 6: Targeted regeneration', status: 'pending' },
          ];
          const transcript = {};
          const update = () => renderGenerationProgress(stages, n + 1, count);
          update();

          // Stage 1 + 2: Generate & validate pairs (with retries)
          let pairs = null;
          stages[0].status = 'active';
          update();
          for (let attempt = 0; attempt < 3; attempt++) {
            try {
              pairs = await genStage1(theme, model, signal);
              stages[0].status = 'completed';
              stages[0].detail = `${pairs.length} pairs generated`;
              stages[1].status = 'active';
              update();
              const [ok, errors] = genStage2(pairs);
              if (ok) {
                stages[1].status = 'completed';
                transcript.stage1 = { pairs: pairs.map(p => ({...p})) };
                transcript.stage2 = { ok: true, errors: [] };
                update();
                break;
              } else {
                stages[1].detail = `Attempt ${attempt+1}: ${errors.join('; ')}`;
                update();
                pairs = null;
                if (attempt < 2) {
                  stages[0].status = 'active';
                  stages[0].detail = `Retrying (attempt ${attempt+2})...`;
                  stages[1].status = 'pending';
                  stages[1].detail = '';
                  update();
                }
              }
            } catch (e) {
              if (e.name === 'AbortError') throw e;
              stages[0].detail = `Attempt ${attempt+1} failed: ${e.message}`;
              update();
              pairs = null;
              if (attempt < 2) {
                stages[0].detail = `Retrying (attempt ${attempt+2})...`;
                update();
              }
            }
          }

          if (!pairs) {
            stages[0].status = 'error';
            stages[0].detail = 'Failed after 3 attempts';
            stages[1].status = 'error';
            update();
            throw new Error(`Failed to generate valid pairs for puzzle ${n+1}`);
          }

          // Stage 3: Parallel distractors
          stages[2].status = 'active';
          let doneCount = 0;
          stages[2].detail = `0 of ${pairs.length} questions done`;
          update();
          const allDistractors = await genStage3Parallel(pairs, model, signal, () => {
            doneCount++;
            stages[2].detail = `${doneCount} of ${pairs.length} questions done`;
            update();
          });
          stages[2].status = 'completed';
          transcript.stage3 = { distractors: allDistractors };
          update();

          // Stage 4: Disguises
          stages[3].status = 'active';
          update();
          const questions = genStage4(pairs, allDistractors);
          stages[3].status = 'completed';
          update();

          // Stage 5: Playtester
          stages[4].status = 'active';
          update();
          const { issues, picks, answerKey } = await genStage5(questions, theme, model, signal);
          transcript.stage5 = { picks, answerKey };
          const highCount = issues.filter(i => i.severity === 'high').length;
          const correctCount = questions.length - issues.filter(i => i.severity === 'high').length;
          stages[4].status = 'completed';
          stages[4].detail = `Playtester solved ${correctCount}/${questions.length} correctly, ${highCount} high + ${issues.length - highCount} low severity issues`;
          update();

          // Stage 6: Regen
          stages[5].status = 'active';
          update();
          if (highCount > 0) {
            const flaggedSet = new Set(issues.filter(i => i.severity === 'high').map(i => i.question).filter(q => q >= 1 && q <= questions.length));
            stages[5].detail = `Regenerating ${flaggedSet.size} question(s)`;
            update();
            await genStage6(questions, issues, pairs, model, signal);
            stages[5].status = 'completed';
            transcript.stage6 = { flagged: [...flaggedSet].map(q => q - 1) };
          } else {
            stages[5].status = 'completed';
            stages[5].detail = 'No regeneration needed';
            transcript.stage6 = { flagged: [] };
          }
          renderGenerationProgress(stages, n + 1, count, true);

          // Save
          const newPuzzle = { theme, publicationDate: dateStr, questions };
          const saveResp = await fetch('/api/save-puzzle', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(newPuzzle),
            signal,
          });
          if (!saveResp.ok) {
            const err = await saveResp.json();
            throw new Error(err.error || 'Save failed');
          }
          generationTranscript = { stages: stages.map(s => ({...s})), tokenUsage: JSON.parse(JSON.stringify(tokenUsage)), stageData: transcript };
        }

        // All done â€” refresh and load
        isGenerating = false;
        generationAbortController = null;
        document.getElementById('genStartBtn').disabled = false;
        document.getElementById('genCancelBtn').classList.add('hidden');

        const datesResp = await fetch('/api/puzzle-dates');
        const dates = await datesResp.json();
        previousThemes = dates.map(d => d.theme).filter(Boolean).slice(-100);
        existingPuzzleDates = new Set(dates.map(d => d.date));
        const select = document.getElementById('dateSelect');
        select.innerHTML = dates.map(d =>
          `<option value="${d.date}" ${d.date === lastGeneratedDate ? 'selected' : ''}>${d.date}${d.theme ? ' \u2014 ' + d.theme : ''}</option>`
        ).join('');

        if (lastGeneratedDate) await loadPuzzle(lastGeneratedDate);
        toggleGeneratePanel();
        showToast(`Generated ${count} puzzle${count > 1 ? 's' : ''} successfully`);
      } catch (e) {
        if (e.name === 'AbortError') return;
        isGenerating = false;
        generationAbortController = null;
        document.getElementById('genStartBtn').disabled = false;
        document.getElementById('genCancelBtn').classList.add('hidden');
        showToast('Generation failed: ' + e.message, true);
      }
    }

    // â”€â”€ Save / Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function savePuzzle() {
      if (!puzzle) return;
      try {
        const resp = await fetch('/api/save-puzzle', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(puzzle),
        });
        const result = await resp.json();
        if (!resp.ok) {
          showToast(result.error || 'Save failed', true);
          return;
        }
        originalJson = JSON.stringify(puzzle);
        dirty = false;
        updateDirtyIndicator();
        showToast('Puzzle saved');

        // Refresh date list in case theme changed
        const select = document.getElementById('dateSelect');
        const currentDate = select.value;
        const datesResp = await fetch('/api/puzzle-dates');
        const dates = await datesResp.json();
        select.innerHTML = dates.map(d =>
          `<option value="${d.date}" ${d.date === currentDate ? 'selected' : ''}>${d.date}${d.theme ? ' â€” ' + d.theme : ''}</option>`
        ).join('');
      } catch (e) {
        showToast('Save failed: ' + e.message, true);
      }
    }

    function exportJSON() {
      if (!puzzle) return;
      const json = JSON.stringify(puzzle, null, 2);
      navigator.clipboard.writeText(json).then(() => {
        showToast('JSON copied to clipboard');
      }).catch(() => {
        // Fallback: select from textarea
        const ta = document.createElement('textarea');
        ta.value = json;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
        showToast('JSON copied to clipboard');
      });
    }

    // â”€â”€ Emoji picker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async function loadEmojiData() {
      try {
        const resp = await fetch('https://cdn.jsdelivr.net/npm/emojilib@4.0.2/dist/emoji-en-US.json');
        if (resp.ok) emojiKeywords = await resp.json();
      } catch (e) {
        console.warn('Failed to load emoji data:', e);
      }
    }

    async function loadAiModel() {
      try {
        const response = await fetch('/api/models');
        const data = await response.json();
        availableModels = data.models || {};
        const modelIds = Object.keys(availableModels);
        // Prefer sonnet
        aiModel = modelIds.find(id => id.includes('sonnet')) || modelIds[0] || null;
        populateGenModelSelect(modelIds);
      } catch (e) {
        console.warn('Failed to load AI models:', e);
      }
    }

    async function callServer(prompt) {
      if (!aiModel) throw new Error('No AI model available');
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: aiModel, prompt })
      });
      const data = await response.json();
      if (!response.ok || data.error) {
        throw new Error(data.error || 'Server error');
      }
      return data.content;
    }

    function findEmojiForWord(word) {
      if (!emojiKeywords || !word) return [];
      const lower = word.toLowerCase().replace(/[^a-z]/g, '');
      if (!lower) return [];
      const exact = [];
      const partial = [];
      for (const [emoji, keywords] of Object.entries(emojiKeywords)) {
        for (const kw of keywords) {
          if (kw === lower) { exact.push(emoji); break; }
          if (kw.includes(lower) || lower.includes(kw)) { partial.push(emoji); break; }
        }
      }
      return [...exact, ...partial.filter(e => !exact.includes(e))];
    }

    function renderEmojiGrid(qIndex, searchQuery = '') {
      if (searchQuery) {
        if (!emojiKeywords) {
          return '<div class="emoji-no-results">Search loading\u2026</div>';
        }
        const q = searchQuery.toLowerCase();
        const results = [];
        for (const [emoji, keywords] of Object.entries(emojiKeywords)) {
          if (results.length >= 64) break;
          if (keywords.some(kw => kw.includes(q))) results.push(emoji);
        }
        if (results.length === 0) {
          return '<div class="emoji-no-results">No emojis found</div>';
        }
        return `
          <div class="emoji-grid">
            ${results.map(e => `<button type="button" class="emoji-option" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
          </div>
        `;
      }

      let html = '';

      // Show suggested emojis based on the question's prompt word
      if (puzzle && puzzle.questions && puzzle.questions[qIndex]) {
        const promptWord = puzzle.questions[qIndex].prompt;
        const suggested = findEmojiForWord(promptWord).slice(0, 8);
        if (suggested.length > 0) {
          html += `
            <div class="emoji-section-label">Suggested</div>
            <div class="emoji-grid">
              ${suggested.map(e => `<button type="button" class="emoji-option suggested" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
            </div>
          `;
        }
      }

      // Show recent emojis if any
      if (recentEmojis.length > 0) {
        html += `
          <div class="emoji-section-label">Recent</div>
          <div class="emoji-grid">
            ${recentEmojis.slice(0, 16).map(e => `<button type="button" class="emoji-option" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
          </div>
        `;
      }

      // Show current category
      const cat = emojiCategories[currentEmojiCategory];
      if (cat) {
        html += `
          <div class="emoji-section-label">${currentEmojiCategory}</div>
          <div class="emoji-grid">
            ${cat.emojis.map(e => `<button type="button" class="emoji-option" onclick="selectEmoji(${qIndex}, '${e}')">${e}</button>`).join('')}
          </div>
        `;
      }

      return html;
    }

    function toggleEmojiPicker(qIndex) {
      // Close any other open pickers
      document.querySelectorAll('.emoji-dropdown.open').forEach(el => {
        if (el.id !== `emoji-dropdown-${qIndex}`) {
          el.classList.remove('open');
        }
      });
      const dropdown = document.getElementById(`emoji-dropdown-${qIndex}`);
      const isOpening = !dropdown.classList.contains('open');
      dropdown.classList.toggle('open');

      // Reset search when opening
      if (isOpening) {
        const searchInput = document.getElementById(`emoji-search-${qIndex}`);
        if (searchInput) {
          searchInput.value = '';
          emojiSearchQuery = '';
        }
        updateEmojiGrid(qIndex);
      }
    }

    function switchEmojiCategory(qIndex, category) {
      currentEmojiCategory = category;
      // Update active tab
      const tabsContainer = document.getElementById(`emoji-tabs-${qIndex}`);
      tabsContainer.querySelectorAll('.emoji-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      // Clear search
      const searchInput = document.getElementById(`emoji-search-${qIndex}`);
      if (searchInput) searchInput.value = '';
      emojiSearchQuery = '';
      // Update grid
      updateEmojiGrid(qIndex);
    }

    function filterEmojis(qIndex, query) {
      emojiSearchQuery = query.toLowerCase();
      updateEmojiGrid(qIndex);
    }

    function updateEmojiGrid(qIndex) {
      const gridContainer = document.getElementById(`emoji-grid-${qIndex}`);
      if (gridContainer) {
        gridContainer.innerHTML = renderEmojiGrid(qIndex, emojiSearchQuery);
      }
    }

    function selectEmoji(qIndex, emoji) {
      const q = puzzle.questions[qIndex];
      q.emoji = emoji;
      // Clear icon when emoji is selected (mutual exclusivity)
      delete q.imageUrl;
      delete q.imageCredit;
      document.getElementById(`emoji-dropdown-${qIndex}`).classList.remove('open');

      // Add to recent emojis
      if (emoji) {
        recentEmojis = [emoji, ...recentEmojis.filter(e => e !== emoji)].slice(0, 16);
        localStorage.setItem('cnmn-recent-emojis', JSON.stringify(recentEmojis));
      }

      markDirty();
      renderPuzzle();
    }

    function handleDirectEmoji(event, qIndex) {
      if (event.key === 'Enter') {
        const input = document.getElementById(`emoji-direct-${qIndex}`);
        const emoji = input.value.trim();
        if (emoji) {
          selectEmoji(qIndex, emoji);
        }
      }
    }

    async function suggestEmojiAI(qIndex) {
      const btn = document.getElementById(`emoji-ai-btn-${qIndex}`);
      if (!btn || btn.disabled) return;
      const q = puzzle.questions[qIndex];
      btn.disabled = true;
      btn.textContent = 'Thinking\u2026';
      try {
        const result = await callServer(
          `Reply with ONLY a single emoji (no text) that best represents the word "${q.prompt}" (synonym: ${q.answer}).`
        );
        const emoji = result.trim().replace(/[^\p{Emoji}]/gu, '').slice(0, 2);
        if (emoji) selectEmoji(qIndex, emoji);
      } catch (e) {
        console.warn('AI emoji suggestion failed:', e);
      } finally {
        btn.disabled = !aiModel;
        btn.textContent = 'Ask AI';
      }
    }

    // Close emoji picker when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.emoji-picker-container')) {
        document.querySelectorAll('.emoji-dropdown.open').forEach(el => {
          el.classList.remove('open');
        });
      }
    });

    // â”€â”€ Icon picker â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function setPickerMode(qIndex, mode) {
      pickerMode[qIndex] = mode;
      const emojiPanel = document.getElementById(`picker-emoji-${qIndex}`);
      const iconPanel = document.getElementById(`picker-icon-${qIndex}`);
      if (emojiPanel) emojiPanel.style.display = mode === 'emoji' ? 'block' : 'none';
      if (iconPanel) iconPanel.style.display = mode === 'icon' ? 'block' : 'none';
      // Update toggle buttons
      const container = document.getElementById(`emoji-dropdown-${qIndex}`);
      if (container) {
        container.querySelectorAll('.image-picker-toggle button').forEach(btn => {
          btn.classList.toggle('active', btn.textContent.toLowerCase() === mode);
        });
      }
      // Auto-search when switching to icon mode
      if (mode === 'icon' && !iconResults[qIndex]) {
        searchIcons(qIndex);
      }
    }

    async function searchIcons(qIndex) {
      const input = document.getElementById(`icon-search-${qIndex}`);
      const query = input ? input.value.trim() : '';
      if (!query) return;

      const grid = document.getElementById(`icon-grid-${qIndex}`);
      if (grid) grid.innerHTML = '<div class="icon-empty">Searching...</div>';

      try {
        const prefixes = ICON_SET_PRIORITY.join(',');
        const resp = await fetch(`https://api.iconify.design/search?query=${encodeURIComponent(query)}&prefixes=${prefixes}&limit=32`);
        const data = await resp.json();
        if (!data.icons || data.icons.length === 0) {
          if (grid) grid.innerHTML = '<div class="icon-empty">No icons found</div>';
          return;
        }
        const icons = data.icons.map(icon => {
          const colonIdx = icon.indexOf(':');
          return { prefix: icon.substring(0, colonIdx), name: icon.substring(colonIdx + 1) };
        });
        icons.sort((a, b) => {
          const ai = ICON_SET_PRIORITY.indexOf(a.prefix);
          const bi = ICON_SET_PRIORITY.indexOf(b.prefix);
          return (ai === -1 ? 99 : ai) - (bi === -1 ? 99 : bi);
        });
        iconResults[qIndex] = icons;
        if (grid) grid.innerHTML = renderIconGrid(qIndex);
      } catch (e) {
        if (grid) grid.innerHTML = `<div class="icon-empty">Search failed: ${e.message}</div>`;
      }
    }

    function renderIconGrid(qIndex) {
      const results = iconResults[qIndex];
      if (!results || results.length === 0) {
        return '<div class="icon-empty">Search for icons above</div>';
      }
      return results.map((icon, i) => `
        <div class="icon-thumb" onclick="selectIcon(${qIndex}, ${i})" title="${icon.prefix}:${icon.name}">
          <img src="https://api.iconify.design/${icon.prefix}/${icon.name}.svg?height=64" alt="${icon.name}" loading="lazy">
        </div>
      `).join('');
    }

    function selectIcon(qIndex, iconIdx) {
      const results = iconResults[qIndex] || [];
      const icon = results[iconIdx];
      if (!icon) return;

      const q = puzzle.questions[qIndex];
      q.imageUrl = `https://api.iconify.design/${icon.prefix}/${icon.name}.svg?height=128`;
      q.imageCredit = {
        name: ICON_SET_NAMES[icon.prefix] || icon.prefix,
        username: icon.prefix,
        profileUrl: `https://icon-sets.iconify.design/${icon.prefix}/`,
      };
      q.emoji = '';  // Clear emoji when icon is selected

      document.getElementById(`emoji-dropdown-${qIndex}`).classList.remove('open');
      markDirty();
      renderPuzzle();
    }

    function clearImage(qIndex) {
      const q = puzzle.questions[qIndex];
      delete q.imageUrl;
      delete q.imageCredit;
      document.getElementById(`emoji-dropdown-${qIndex}`).classList.remove('open');
      markDirty();
      renderPuzzle();
    }

    // â”€â”€ Dirty tracking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function markDirty() {
      dirty = JSON.stringify(puzzle) !== originalJson;
      updateDirtyIndicator();
    }

    function updateDirtyIndicator() {
      const el = document.getElementById('dirtyIndicator');
      el.classList.toggle('hidden', !dirty);
    }

    function onDateChange(date) {
      if (dirty) {
        if (!confirm('You have unsaved changes. Discard and load a different puzzle?')) {
          // Revert select to current puzzle date
          document.getElementById('dateSelect').value = puzzle.publicationDate || '';
          return;
        }
      }
      generationTranscript = null;
      loadPuzzle(date);
    }

    window.onbeforeunload = function(e) {
      if (dirty) {
        e.preventDefault();
        return '';
      }
    };

    // â”€â”€ Utilities â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function escapeAttr(str) {
      return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function showToast(message, isError) {
      const existing = document.querySelector('.toast');
      if (existing) existing.remove();

      const toast = document.createElement('div');
      toast.className = 'toast' + (isError ? ' error' : '');
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 300);
      }, 2000);
    }

    // â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    init();
  </script>
</body>
</html>
